# Classes22

## 1. Inspection of classes and instances

1.1. Check if instance

isinstance(True, bool)

> True
> isinstance(True, int)

#### 1.1. How to inspect class atributes?

```python
class One:
    x = 1
    y = 2

print(list(One.__dict__.keys()))

> ['__module__', 'x', 'y', '__dict__', '__weakref__', '__doc__']
```

The same without builtin attributes

```python
list(name for name in One.__dict__ if not name.startswith('__'))

> ['x', 'y']
```

#### 1.2. How to inspect instance atributes?

That won't work:

```python
class One:
    x = 1
    y = 2

I = One()

print(list(I.__dict__.keys()))

> []
```

The only way is to use **\_\_dir__** method:

```python
x = I.__dir__()
y = dir(I)

print(x)
# print(y)

> ['__module__',
 'x',
 '__dict__',
 '__weakref__',
 '__doc__',
 '__repr__',
 '__hash__',
 '__str__',
 '__getattribute__',
 '__setattr__',
 '__delattr__',
 '__lt__',
 '__le__',
 '__eq__',
 '__ne__',
 '__gt__',
 '__ge__',
 '__init__',
 '__new__',
 '__reduce_ex__',
 '__reduce__',
 '__subclasshook__',
 '__init_subclass__',
 '__format__',
 '__sizeof__',
 '__dir__',
 '__class__']
```

But result would be printed!

#### 1.3. How to get class of superclass?

```python
class One: pass

print(One.__class__)

> <class 'type'>
```

#### 1.4. How to get class of instance?

```python
class One: pass

I = One()
print(I.__class__)

> <class '__main__.One'>
```

#### 1.5. How to get superclasses of class?

```python
class One(): pass
class Two(One): pass
class Three(Two, One): pass

print(Three.__class__) # That won't work

> <class 'type'>

print(Three.__bases__)

> (<class '__main__.Two'>, <class '__main__.One'>)
```

## 2. Concepts

### 2.1. Theory

#### 2.1.1. What are three crutial class distinctions?

- Namespaces like modules
- Generating multiple instances
- Customization via inheritance
- Operator overloading methods

### 2.2. Creation

#### 2.2.1. How to create a simplest class?

Class can be created with **class** statement:

```python
class One:
    pass
```

#### 2.2.2. How to create an instance of class?

Instance can be created with assignment expression and class like function call statement:

```python
class One: pass

I = One()

print(type(I))

> <class '__main__.One'>
```

### 2.3. Methods

#### 2.3.1. How to add methods to a class (2 ways)?

Inside the **class** statement:

```python
class One:
    def foo(self):
        print('foo')

One.foo()

> foo
```

Outside the **class** statement:

```python
class One: pass

I = One()

# Using lambda function

One.foo = lambda self: print('foo')

I.foo()

> foo

# Using def statement

def boo(self):
    print('boo')

One.boo = boo

I.boo()

> boo
```

**Remember!** By convention the first argument **self** in the funciton is the instance object.

#### 2.3.2. How methods could be called (2 ways)?

By **instance**:

```python
class One:
    def method(self, arg):
        print(arg)

I = One()
I.method("Hi, Mike!")

> Hi, Mike!
```

By **class**:

```python
C.method(I, "Hi, Janny!")

> Hi, Janny!
```

#### 2.3.3. How instance could be passed into the method (2 ways)?

Implicitly as a hidden first argument in a method call:

```python
class One:
    def func(self, x):
        self.x = x

I = One()
I.func(3)
print(I.x)

> 3
```

Explicitly as an argument of class method call:

```python
class One:
    def func(self, x):
        self.x = x

I = One()

print(One.func(I, 3))

> 3
```

#### 2.3.4. How to bound method to a class?

```python
class One:
    pass

def func(self, x):
    self.x = x

I = One()
One.func = func

I.func(4)
print(I.x)

> 4
```

#### 2.3.5. How to unbound method off a class?

```python
class One:
    x = 'Hey, you! '
    def func(self, arg):
        print(self.x + arg)
    def change(self):
        self.x = 'Hm... '

I = One()
I.func('Hi!')

> Hey, you! Hi!

f = I.func
f('Hello!')

> Hey, you! Hello!

I.change()
I.func('Hi!')

> Hm... Hi!

f('Hi again!')

> Hm... Hi again!
```

#### 2.3.6. Give an example of methods without instance

```python
class One:
    def func1(x, y):
        return x + y
    def func2(self, x, y):
        self.result = x + y
        return self.result

I = One()

print(I.func1(1, 2)) # TypeError: func1() takes 2 positional arguments but 3 were given

One.func1(1, 2)

> 3

One.func2(I, 1, 2)

> 3
```

#### 2.3.7. How to use methods as variables in a call loop?

```python
class One:
    def x2(self, x):
        return x * 2
    def x3(self, x):
        return x * 3

x = One()
y = One()

actions = [x.x2, x.x3, y.x2, y.x3]
for act in actions:
    print(act(4))

> 8
> 12
> 8
> 12
```

### 2.4. Attributes

#### 2.4.1. How to add attributes to a class (2 ways)?

Inside **class** statement:

```python
class One:
    x = 2

print(One.x)

> 2

I = One()

print(I.x)

> 2
```

Outside **class** statement:

```python
class One: pass

I = One()

print('x' in One.__dict__)

> False

One.x = 2

print(I.x)

> 2
```

#### 2.4.2. How to add attributes to an instance?

Use method in the class:

```python
class One():
    x = 0 # Attribute
    def func(self, x): # Method
        self.x = x # Attribute "x" will be rewriten only for instance
        self.y = x + 5 # Attribute "y" will be created only for instance

I = One()
print(One.x, I.x)

> 0 0

I.func(2)
print(One.x, I.x, I.y)    

> 0 2 7

print(One.y) # AttributeError: type object 'One' has no attribute 'y'
```

If ones attribute was reassigned in instance it never become a class attribute again:

```python
class One:
    x = 0

I = One()
I.x = 5
One.x = 1

print(One.x, I.x)

> 1 5
```

#### 2.4.3. How one instance attributes impact another?

No how!

```python
class One():
    y = 4
    def func(self, x):
        self.x = x
        self.y = 159

I1 = One()
I2 = One()

I1.func(3)
print(I1.x, I1.y)

> 3 159

print(I2.y) # Class attribute was not changed

> 

print(I2.x) # AttributeError: 'One' object has no attribute 'x'
```

#### 2.4.4. How to get attribute value?

Directly from the class object:

```python
class One():
    x = 8

print(One.x)

> 8

print(One.__dict__['x'])

> 8
```

From the instance object:

```python
I = One()

print(I.x)
```

But instance doesn't have this attributes, it was gotten by the inheritance search:

```python

print('x' in I.__dict__)

> False
```

If attribute was changed via instance assignement it become an instance attribute:

```python
I.x = 5

print(I.__dict__)

> {'x': 5}
```

### 2.5. Pseudoprivate names

Within a **class** statement any names that start with two underscores but don't end with two underscores are automatically expanded to include the name of the enclosing class at their fron.
For instance: __X within a class Spam becomes **_Spam__X**

#### 2.5.1. How to create a pseudoprivate attribute and method in the class?

Hide some attributes:

```python

class One:
    __X = 3
    def __init__(self, Y):
        self.__Y = Y

print(One.__X) # AttributeError: type object 'One' has no attribute '__X'

I = One('abc')
print(I.__Y) # AttributeError: 'One' object has no attribute '__Y'

print(One._One__X, I._One__Y)

> 3 abc
```

Hide some methods:

```python
class One:
    def __method(self):
        print('Super method')
    def other(self):
        print('Super other')
        self.__method()

I = One()
I.other()

> Super other
> Super method

I.__method() # AttributeError: 'One' object has no attribute '__method'
```

### 2.6. Inheritance

#### 2.6.1. Give an example of polymorphism with classes

```python
class Ancestor():
    x = 'I\'m'
    def show(self):
        print(x, 'Ancestor')

class Descendant(Ancestor):
    def show(self):
        print(x, 'Descendant')

I1 = Ancestor()
I2 = Ancestor()
I3 = Descendant()

for i in [I1, I2, I3]:
    i.show()

> I'm Ancestor
> I'm Ancestor
> I'm Descendant
```

#### 2.6.2. How attribute and method inheritance search works?

1. Find the first occurrence of attribute by looking in object
2. If there is no, look in all classes above object from bottom to top and left to right.

Instance inherits from class:

```python
class One:
    x = 0

I = One()

print(I.x)

> 0
```

Instance inherits and can rewrite inherited attributes and methods:

```python

class One:
    x = 1

I = One()
I.x = 2

print(C.x)

> 1

print(I.x)

> 2
```

Subclass (derived class) inherits from superclass (base class):

```python
class SuperClass():
    a = 1

class SubClass(SuperClass):
    pass

print(SubClass.a)

> 1
```

#### 2.6.3. Give an example of multiclass inheritance

One class can inherits from several superclasses:

```python
class One():
    a = 1
    b = 4

class Two():
    a = 2

class Three(One, Two):
    pass

I1 = Three()
I2 = Three()

I1.a = 3
print(I1.a)

> 3

print(I2.a)

> 1

print(Three.b)

> 4

print(I2.b)

> 4
```

#### 2.6.4. How attributes and methods simultanious searches works?

Attributes and methods searches are independent:

```python

class One():
    attr = 1
    def func(self, x):
        return self.attr + x

I = One()
print(I.func(2))

> 3

II = One()

I.attr = 2
print(I.func(2))

> 4

print(II.func(2))

> 3
```

#### 2.6.5. How it's better to customize methods?

It's better to use original method call in a new method:

```python
class One():
    def func(self, x):
        return x ** 2

class Two(One):
    def func(self, x):
        return One.func(self, x + 2) * 2

I1 = One()
print(I1.func(2))

> 4

I2 = Two()
print(I2.func(2))

> 32
```

#### 2.6.6. How it's better to customize constructor?

```python
class Employee():
    def __init__(self, name, job=None, salary=0):
        self.name = name
        self.job = job
        self.salary = salary

class Manager(Employee):
    def __init__(self, name, salary):
        Employee.__init__(self, name, 'manager', salary)

I = Manager('Bob', 1000)
print(I.job)

> manager
```

### 2.7. Operator overloading methods

List of overloading methods: Lutz Learning p. 889

#### 2.7.1. How it is possible syntactically recognize operator overloading methods?

- Methods named with double underscores (\_\_X__) are special hooks.
- Such methods are called automatically when instances appear in built-in operations.
- Classes may override most built-in type operations, such as call function, indexing, getting attribute, addition and so on.

#### 2.7.2. How to create a class constructor?

```python
class Person():
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender

Anna = Person('Anna', 19, 'female')
Bob = Person('Bob', 23, 'male')

print(Anna.age)

> 19

print(Bob.gender)

> male
```

#### 2.7.3. Give examples of printing methods overloading

```python
class One():
    x = 4
    def __repr__(self):
        return 'One: %s]' % self.x

I = One()
print(I)

> One: 4
```

```python
class One():
    x = 5
    def __str__(self):
        return 'One: %s]' % self.x

I = One()
print(I)

> One: 5
```

#### 2.7.4. Give examples of overloading addition and substraction methods

```python
class One():
    def __init__(self, value):
        self.data = value

    def __add__(self, other):
        return One(self.data + other)
    def __sub__(self, other):
        string = self.data.replace(other, '')
        return One(string)
    
    def __str__(self):
        return '[One: %s]' % self.data

a = One('My name')
print(a)

> [One: My name]

b = a + ' is Vera'
print(b)

> [One: My name is Vera]

c = a - 'am'
print(c)

> [One: My ne]
```

#### 2.7.5. Give an example of overloading getting existing attribute method

```python
class One():
    x = 3
    def __getattribute__(self, attr):
        print('foo', attr, self[attr])

I = One()
I.x

> foo x 3 # That doesn't work!!!! :(((

I = One()
One.x # 3

I.x # Error
```

#### 2.7.6. Give an example of overloading getting undefined attribute method

```python
class One():
    x = 3
    def __getattr__(self, attr):
        print('foo')

I = One()
I.x

> 3 # As usually

I.c

> foo
```

#### 2.7.7. Create an iterator with overloading methods (3 ways)

```python
class Iterator:
    def __init__(self, start, stop):
        self.value = start - 1
        self.stop = stop
    def __iter__(self):
        return self
    def __next__(self):
        if self.value > self.stop:
            raise StopIteration
        self.value += 1
        return self.value

t = Iterator(1, 8)

next(t)

> 1

next(t)

> 2

h = Iterator(10, 15)

next(h)

> 10

next(t)

> 3
```

Generator with yield statement:

```python
class Iterator:
    def __init__(self, start, stop):
        self.start = start
        self.stop = stop
    def __iter__(self):
        for value in range(self.start, self.stop + 1):
            yield value

I = Iterator(1, 9)
t = iter(I)

next(t)

> 1
```

#### 2.7.8. Create an iterator with customizing step function

```python
class Iterator:
    def __init__(self, start, stop):
        self.value = start - 1
        self.stop = stop
    def __iter__(self):
        return self
    def __next__(self, x = 1):
        if self.value > self.stop:
            raise StopIteration
        self.value += x
        return self.value

t = Iterator(3, 8)

next(t)

> 3

t.__next__(3)

> 6
```

#### 2.7.9. Overload call function method

```python
class Callee:
    def __call__(self, *pargs, **kargs):
        print('Called:', pargs, kargs)

I = Callee()
I(1, 2, 3)

> Called: (1, 2, 3) {}

I(1, 2, 3, x=4, y=5)

> Called: (1, 2, 3) {4, 5}
```

## 3. Advanced class techniques

#### 3.1 Create an object factory

```python
def factory(cl, *pargs, **kargs):
    return cl(*pargs, **kargs)

class One:
    def fn(self, msg):
        print(msg)

class Two:
    def __init__(self, nm, jb=None):
        self.name = nm
        self.job = jb

obj1 = factory(One)
obj2 = factory(Two, 'Ann', 'Manager')
obj3 = factory(Two, name = 'Susy')
```

#### 3.2. Class for printing attributes

```python
class AttrDisplay:
    """
    Special class which provide an overloading for printing, will print all attributes and methods
    """
    def gather(self):
        attrs = [attr for attr in dir(self)]
        # print(self.__dict__.keys())
        return attrs
    
    def __repr__(self):
        return 'Attrs: %s' % (self.gather())

class One(AttrDisplay):
    x = 3

class Two(One, AttrDisplay):
    y = 4

I = Two()

print(I)
```

#### 3.3. Class inheritance techniques

Four different ways of inheritance

- Inheritor
- Replacer
- Extender
- Provider

```python
class Super:
    def method(self):
        print('In Super.method')
    def delegate(self):
        self.action()
    def action(self):
        assert False, '%s method "action" must be defined!' % type(self).__name__

class Inheritor(Super): pass

class Replacer(Super):
    def method(self):
        print('In Replacer.method')

class Extender(Super):
    def method(self):
        print('Starting Extender.method')
        Super.method(self)
        print('Ending Extender.method')

class Provider(Super):
    def action(self):
        print('In Provider.action')

I1 = Inheritor()
I1.method()

> In Super.method

I1.delegate() # AssertionError: Inheritor method "action" must be defined!

y = Extender()
y.method()

> Starting Extender.method
> In Super.method
> Ending Extender.method

x = Provider()
x.delegate()

> In Provider.action
```

#### 3.4. Use delegation and overloading to log method calls

This technique can be used to log method calls, route method calls to custom logic, adapt a class to a new interface...

```python
class Wrapper:
    def __init__(self, object):
        self.wrapped = object
    def __getattr__(self, attrname):
        print('Trace: ' + attrname)
        return getattr(self.wrapped, attrname)

x = Wrapper([1,2,3])
x.append(4)

> Trace: append

x.wrapped # Do without tracing

> [1, 2, 3, 4]

x = Wrapper({'a': 1, 'b': 2})
list(x.keys())

> Trace: keys
```

#### 3.5. Create a simple processor with defined outside method

```python
class Processor:
    def __init__(self, reader, writer):
        self.reader = reader
        self.writer = writer
    def process(self):
        while True:
            data = self.reader.readline()
            if not data: break
            data = self.converter(data)
            self.writer.write(data)
    def converter(self, data):
        assert False, 'Converter must be defined'

class Uppercase(Processor):
    def converter(self, data):
        return data.upper()

import sys
obj = Uppercase(open('/Users/master/Desktop/file.txt'), sys.stdout)
obj.process()

> ABCDEFG
```

#### 3.6. Pickle and unpickle object

```python
import pickle

class One():
    def __init__(self, name):
        self.name = name

obj = One('Ann')
print(obj.name)

> Ann

file1 = open('/Users/master/Desktop/new.txt', 'wb')
pickle.dump(obj, file1)

file2 = open('/Users/master/Desktop/new.txt', 'rb')
obj2 = pickle.load(file2)

print(obj2.name)

> Ann
```