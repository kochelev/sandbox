# Functions

## 1. Basics

### 1.1. Define, call and return

#### 1.1.1. How to create function (procedure) (2 ways)?

**def** statement creates an object and assigns it to a name.

```python
def function(x, y):
  print('I\'m a function!', x, y)
```

**lambda** expression creates an object and returns it as a result.

```python
func = lambda x, y: x * y
func(2,3)

> 6
```

#### 1.1.2. How to call a function (3 ways)?

As an expression:

```python
def func(x, y):
    print(x * y)

func(1, 2)

> 2
```

As an assignment:

```python
x = func(1, 2)

> 2
```

Indirect call through anothe function:

```python
def indirect(func, args):
    func(args)

indirect(echo, 'Hello World!')

> Hello World!
```

#### 1.1.3. Give an example of return (create function)

```python
def func(x):
  return x ** 2

y = func(3)

print(y)

> 9
```

#### 1.1.4. What will return a function without return

None

```python
def func(x):
    print(x)

y = func(4)

> 4

print(y)

> None
```

#### 1.1.5. Can one create functions within if statement?

Yes

```python
import math

x = -3

if x > 0:
  def func(arg):
    return math.sqrt(arg)
else:
  def func(arg):
    return math.sqrt(-arg)

print(func(x))

> 1.7320508075688772
```

#### 1.1.6. How to attach attributes to a function?

```python
def func():
    print('foo')

func.attr = 'boo'
```

### 1.2. Scopes

#### 1.2.4. What is LEGB rule?

When you use unqualified variable inside a function Python searches up to four scopes:
- L (local)
    - functions
    - comprehensions (generator, lists, set, dictionaries)
    - exceptions
    - class statements
    - But not for loops!!!
- E (local scopes of any Enclosing defs and lambdas)
- G (global)
- B (built-in scope)
then reports an error.

#### 1.1.1. How to inspect built-in scope (2 ways)?

```python
import builtins
dir(builtins)

> ...
```

```python
dir(__builtins__)
```

#### Redefine open builtin name

```python
open = 'abc'

f = open('/Users/master/Desktop/file.txt', 'wb')

> TypeError: 'str' object is not callable
```

#### 1.2.1. Create a global variable and use it

```python
x = 3

def func(y):
  return x * y

print(func(2))

> 6
```


#### 1.2.1. Give example of global, nonlocal and local variables

```python

x = 3 # global

def func():
  y = 4 # local for func, nonlocal for nested function
  def nested():
    z = 5 # local for nested
```

#### 1.2.2. Create global variable within function

```python
x = 1
def outer():
  global y
  y = 2

outer()

print(x, y)

> 1 2
```

#### 1.2.3. Redefine existing global variable

```python
x = 1

def outer():
  global x
  x = 2
  def inner():
    global x
    x = 3
    
  inner()

outer()

print(x)

> 3
```


#### 1.1.1. Give examples of exotic way to change global variable within a function

Importing it's own module file.

```python
x = 3

def func():
    import mymodule
    mymodule.x += 1

func()

print(x)

> 4
```

Using sys module.

```python
x = 3

def func():
    import sys
    glob = sys.modules['mymodule']
    glob.var += 1

func()
print(x)

> 4
```

#### 1.1.1. Nested scope example

```python
x = 3

def outer():
    x = 4

    def inner():
        print(x)

    inner()

outer()

> 4
```

#### 1.1.1. Use nonlocal

```python
def outer():
    x = 3
    def inner():
        x += 1 # UnboundLocalError: local variable 'x' referenced before assignment
    inner()
    return x

print(outer())
```

```python

def outer():
  x = 4
  
  def inner():
    nonlocal x
    y += 1
  
  inner()
  return x

print(outer())

> 5
```

#### 1.1.1. How to make nested function remember some state

```python

def creator():
    x = 99
    def func():
        print(x)

    return func

act = creator()
act()

> 99
```

#### 1.1.1. Closures: function factories

```python

def power(n):
    def action(x):
        return x ** n
    return action

square = power(2)
print(square(4))

> 16
```

```python

def power(n):
    return lambda x: x ** n

square = power(2)
print(square(4))

> 16
```

#### 1.1.1. Give example of retaining enclosing scope with defaults

```python
def outer():
    x = 88
    return lambda a, x = x: a + x

act = outer()
print(act(2))

> 90
```

#### 1.1.1. Create a counter using closure and nonlocal

That won't work:

```python
def iterator(start):
    state = start
    def next(increment):
        state += increment # UnboundLocalError: local variable 'state' referenced before assignment
        return state

    return next

inc = iterator(23)
x = inc(2)
print(x)
```

```python
def iterator(start):
    
    state = start

    def next(increment):
        nonlocal state
        state += increment
        return state

    return next

inc = iterator(23)
x = inc(2)
print(x)

> 25
```

### 1.3. Function attributes

#### Create an iterator using function attributes

```python
def outer(start):

    def inner(increment):
        inner.state += increment
        return inner.state

    inner.state = start

    return inner

inc = outer(35)

print(inc(3))

> 38

print(inc(5))

> 43

print(inc.state)

> 43
```

### 1.3. Arguments

#### 1.3.1. How will changing immutable argument impacts caller?

No how

```python
x = 99

def func(num):
    num = 88

func(x)

print(x)

> 99
```

#### 1.3.2. How will changing mutable argument impacts caller?

```python
x = [1, 2, 3]

def func(array):
    array[1] = 0

func(x)

print(x)

> [1, 0, 3]
```

#### 1.3.3. How it is possible to avoid changing mutable arguments

Make a full copy of element:

```python
x = [1, 2, 3]
def func(array):
    array[1] = 0

func(x.copy())

print(x) # x[:], tuple(x)

> [1, 2, 3]
```

#### 1.3.4. Pass arguments by position

```python
def func(x, y, z):
    return x * y * z

print(func(1, 2, 3))

> 6
```

#### 1.3.5. Pass keyword arguments, matched by name

```python
def func(x, y, z):
    return x * y * z

print(func(y = 2, z = 3, x = 1))

> 6
```

#### 1.3.6. Pass iterables

```python
def func(*args):
    print(args)

L = [1, 2, 3, 4, 5]
func(*L)

> (1, 2, 3, 4, 5)
```

```python
def func(x, y, z):
    print(x, y, z)

L = [1, 2, 3]
func(*L)

> 1 2 3
```

#### 1.3.7. Pass dictionary

```python
def func(**kwargs):
    print(kwargs)

D = {'x': 1, 'y': 2, 'z': 3}
func(**D)

> {'x': 1, 'y': 2, 'z': 3}
```

```python
def func(x, y, z):
    print(x, y, z)

D = {'y': 2, 'z': 3, 'x': 1}
func(**D)

> 1 2 3
```

#### 1.3.8. Get a normal argument

```python
def func(x):
    print(x)

func(3)

> 3
```

#### 1.3.9. Get an argument with default value if not given

```python
def func(x = 3):
    print(x)

func()

> 3
```

#### 1.3.10. Get an arguments as a tuple

```python
def func(*args):
    print(args)

func(1, 2, 3)

> (1, 2, 3)
```

#### 5.2.4. Arguments collectors

```python
def func(x, *other):
  print(x)
  print(*other)
  print(other)
  print(type(other))
  
func(1, 2, 3, 4)

> 1
  2 3 4
	(2, 3, 4)
  <class 'tuple'>
```

#### 1.3.11. Get an arguments as a dictionary

```python
def func(**args):
    print(args)

func(x = 1, y = 2, z = 3)

> {'x': 1, 'y': 2, 'z': 3}
```

#### 1.3.12. Combine positional and keyword arguments

```python
def func(x, y, z):
    print(x, y, z)

func(1, z = 3, y = 2) # Positional always first

> 1 2 3
```

#### 1.3.13. Positional, keyword and defaults

```python
def func(x, y, z = 3): # Default always last
    print(x, y, z)

func(1, y = 2)

> 1 2 3

func(1, y = 2, z = 4)

> 1 2 4
```

#### 1.3.14. Give an example of arbitrary arguments

```python
def func(a, *pargs, **kargs):
    print(a, pargs, kargs)

func(1, 2, 3, x = 4, y = 5)

> 1 (2, 3) {'x': 1, 'y': 2}
```

#### 1.3.15. Unpacking arguments

```python
def func(a, b, c, d, e, f):
    print(a, b, c, d, e, f)

func(1, *(2, 3), d = 4, **{'e': 5, 'f': 6})

> 1 2 3 4 5 6
```

#### 1.3.16. Create an example of applying function generically

```python

func1 = lambda x: x ** 2
func2 = lambda x, y, z: x * y * z

if False:
    action, args = func1, (1,)
else:
    action, args = func2, (1, 2, 3)

print(action(*args))

> 6
```

#### 1.3.17. Create a simple tracer function

```python
def tracer(func, *pargs, **kargs):
    print('Calling:', func.__name__)
    return func(*pargs, **kargs)

def func(a, b, c, d):
    return a + b + c + d

print(tracer(func, 1, 2, c = 3, d = 4))

> Calling: func
> 10
```

#### 1.3... Arbitrary amount of arguments

```python
def func(a, *b):
    print(a, b)

func(1, 2, 3, 4, 5)
```

#### 1.3.18. Create a function with several keyword-only arguments (few examples)

```python
def func(a, *b, c, d):
    print(a, b, c, d)

func(1, 2, 3, 4, 5, c = 6, d = 7)
func(1, d = 2, c = 4)
func(a = 1, c = 2, d = 3)

>
1 (2, 3, 4, 5) 6 7
1 () 4 2
1 () 2 3
```

Keyword-only arguments:

```python
def func(*, a, b):
    print(a, b)

func(a = 1, b = 2)

> 1 2
```

Several positional and the rest keyword-only:

```python
def func(a, b, *, c, d):
    print(a, b, c, d)

func(1, 2, c = 3, d = 4)

> 1 2 3 4
```

#### Common ordering rule for arguments

```python
def func(a, b, *pargs, c = 3, d, **kargs):
    print(a, b, pargs, c, d, kargs)

func(1, 2, 3, 4, 5, c = 6, d = 7, e = 8, f = 9)

> 1 2 (3, 4, 5) 6 7 {'e': 8, 'f': 9}

func(1, 2, 3, 4, 5, d = 7, e = 8, f = 9)

> 1 2 (3, 4, 5) 3 7 {'e': 8, 'f': 9}
```

#### Writem you own print function

```python

import sys

def printX(*args, **kargs):
    sep = kargs.pop('sep', ' ')
    end = kargs.pop('end', '\n')
    file = kargs.pop('file', sys.stdout)
    if kargs: raise TypeError('extra keywords: %s' % kargs)
    output = ''
    first = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False

    file.write(output + end)

printX(3, 'abc', 1234, sep = ' | ')

> 3 | abc | 1234
```

### 1.4. Recursive Functions

#### 1.4.1. Write function counting sum of numbers in the list with direct recursion

```python
def sumElem(L):
    print(L)
    return L[0] if len(L) == 1 else L[0] + sumElem(L[1:])

L = [10, 2, 23, 5, 28]
S = sumElem(L)
print(L, 'Sum:', S)

>
[10, 2, 23, 5, 28]
[2, 23, 5, 28]
[23, 5, 28]
[5, 28]
[28]
[]
[10, 2, 23, 5, 28] Sum: 68
```

```python
def sumElem(L):
    print(L)
    first, *rest = L
    return first if not rest else first + sumElem(rest)

L = [10, 2, 23, 5, 28]
S = sumElem(L)
print(L, 'Sum:', S)

> The same result
```

#### 1.4.2. Write previous function as indirect recursion

```python
def func1(L):
    if not L:
        return 0
    else:
        return func2(L)

def func2(L):
    return L[0] + func1(L[1:])

L = [10, 2, 23, 5, 28]
S = sumElem(L)
print(L, 'Sum:', S)

> The same result
```

#### 1.4.3. Do the same with the loop

```python
L = [10, 2, 23, 5, 28]
S = 0
for x in L: S += x
print(L, 'Sum:', S)
```

#### 1.4.4. Compute sum of arbitrary shaped structures (e.g. find sum of all elements in a list [1, [2, [3, 4], 5], 6, [7, 8]]) using recursion

```python
def flatten(x):
    L = []
    if isinstance(x, list):
        for i in x:
            if isinstance(i, list):
                L.extend(flatten(i))
            else:
                L.append(i)
        return L
    else:
        raise IndexError('Function flatten param should be a list')

L = [1, [2, [3, 4], 5], 6, [7, 8]]
print(sum(flatten(L)))

> 36
```

#### 1.4.5. Do the same with loop statement

First-in-first-out queue:

```python
def flatten(x):
    L = []
    if isinstance(x, list):
        items = list(x)
        while items:
            front = items.pop(0)
            if isinstance(front, list):
                items.extend(front)
            else:
                L.append(front)
        return L
    else:
        raise IndexError('Function flatten param should be a list')

L = [1, [2, [3, 4], 5], 6, [7, 8]]
print(sum(flatten(L)))

> 36
```

Last-in-first-out queue:

```python
if isinstance(front, list):
    items[:0] = front
else:
    L.append(front)
```

#### 1.4.6. How to check cycling in recursion

```python
if state not in visited:
    print('Do something')
else:
    visited.append(state) # x.add(state), x['state'] = True
```

```python
visited.add(front)
print('Do something')
items.extend([x for x in front if x not in visited])
```

#### 1.4.7. How to expand Python recursive calls depth limit

```python
import sys
print(sys.getrecursionlimit())

> 3000

sys.setrecursionlimit(10000)
help(sys.setrecursionlimit)
```

More on recursion look on the page 591 Lutz's Learning Python.

### 1.5. Function Objects

#### 1.5.1. How to get function name?

```python
def func():
    pass

print(func.__name__)

> func
```

#### 1.5.2. How to get function attributes?

```python
def func():
    pass

dir(func)

> ...
```

#### 1.5.3. How to get function code attributes?
```python
def func(x):
    y = 3
    return x * y

dir(func.__code__)

> ...
```

#### 1.5.4. How to get function variables?

```python
def func(x):
    y = 3
    return x * y

func.__code__.co_varnames

> ('x', 'y')
```

#### 1.5.5. How to get amount of function arguments?

```python
func.__code__.co_argcount

> 1
```

#### 1.5.6. How to assign attribute to a function?

```python
func.attr = 0
func.attr += 2

print(func.attr)

> 2

print([x for x in dir(func) if not x.startswith('__')])

> ['attr']
```

### 1.6. Function Annotation

#### 1.6.1. Give an example of annotating arguments

```python
def func(x: 'Description 1', y: (1, 10), z: float = 4.0) -> int:
    return x + y + z

func(2, 3.3, 4.3)

> 9.6

print(func.__annotations__)

> {'x': 'Description 1', 'y': (1, 10), 'z': <class 'float'>, 'return': <class 'int'>}
```

### 1.6. Lambda function

#### 1.6.1. Create a lambda function which multiplicate arguments with default values

```python
A = [1, 2, 3]

multiplicate = (lambda x, y, z = 1: x * y * z)

print(multiplicate(*A))

> 6
```

#### 1.6.2. Create simple lambda function which returns max of two elements

```python
A = [3, 5]

maximum = (lambda x, y: x if x > y else y)

print(maximum(*A))

> 5
```

#### 1.6.3. How to perform loops in lambda function? Create function which returns a list of arguments

```python
makealist = (lambda L: [x for x in L]) # list(map(print, L))
print(makealist('abc', 'def', 'gih'))

> ['abc', 'def', 'gih']
```

#### 1.6.4. Create a function which prints all arguments

```python
printall = (lambda *L: [print(x) for x in L])
a = printall('abc', 'def', 'gih') # Result should be assigned for not to be automatically printed in Jupyter

>
abc
def
gih
```

#### 1.6.4. Create a cloasure with nested lambda functions

```python
power = (lambda y: (lambda x: x ** y))
square = power(2)

print(square(4))

> 16
```

## 2. Functional Programming Tools

### 2.1. map

#### 2.1.1. Create a function which produces square of a number and implement it to a list of numbers

```python
def square(x):
    return x ** 2

T = [1, 2, 3, 4]

list(map(square, T))

> [1, 4, 9, 16]
```

```python
LT = [(1,2), (3,4)]

def func(args):
    print(*args)

print(list(map(func, LT)))
>
1 2
3 4
[None, None]
```

#### 2.1.2. Create a function which produces multiplication of two arguments and implement it to lists of numbers

```python
def multiplicate(x, y): return x * y

T = [1, 2, 3, 4]
K = [3, 5, 1]

list(map(multiplicate, T, K))

> [3, 10, 3]
```

### 2.2. filter

#### 2.2.1. Write a script which returns only even numbers from the range

```python
L = list(filter((lambda x: x if (x % 2) == 0 else None), range(-5, 5)))

print(L)

> [-4, -2, 2, 4]
```

#### 2.2.2. Do the same with list comprehensions

```python
L = [x for x in range(-5, 5) if (x % 2) == 0]
print(L)

> [-4, -2, 0, 2, 4]
```

#### 2.2.3. Mix of map and filter: return squares of even elements from the list

```python
R = list(map((lambda x: x ** 2), filter((lambda x: x % 2 == 0), range(10))))

print(R)

> [0, 4, 16, 36, 64]
```

### 2.3. Functional call «reduce»

#### 2.3.1. Write code which counts sum of list elements using reduce operator

```python
from functools import reduce

L = [1, 2, 3, 4]
func = lambda x, y: x + y

print(reduce(func, L))

> 10
```

#### 2.3.2. Create your own reduce function

```python
def myreduce(func, data):
    res = data[0]
    for i in data[1:]:
        res = func(res, i)
    return res

print(myreduce((lambda x, y: x + y), [1, 2, 3, 4]))

> 10
```

#### 2.3.3. Show the how default return of reduce call works

```python
R = reduce((lambda x, y: x + y), [], 'List is empty')

print(R)

> List is empty
```

### 2.4. zip

```python
Z = zip([1, 2, 3], [4, 5, 6])

print(list(Z))

> [(1, 4), (2, 5), (3, 6)]
```

and unzip

zip(*[(1, 2), (3,4)]) = [1,3](2,4)