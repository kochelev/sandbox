# Core Data Types

Python has several groups of data types:

Python has two types of types (built-in and imported):

- Internal
- From basic libraries
- From external libraries

Short classification of Python Data Types

1) By structure:

- **sequences** (iterable) — a positional ordered collection of objects, maintain left-to-right order among the items it contain.
  - Operations:
    - Indexing
- **mappings** — collection of objects, which stores objects by **key** instead of by relative position.

2) By applying changes:

- **immutable** (numbers, strings, tuples) — cannot  be changed in place after they are created.
- **mutable** (lists, dictionaries, sets) — can be changes in place.

Full classification of Python Core Data Types


| Group                             | Core                                                         | Built-in Modules                                             |
| --------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Internals                         | Type (**type**: NoneType, type, int etc.)<br />Code<br />Frame<br />Traceback - Stack tracebacks (?) |                                                              |
| Other                             | None (**NoneType**)<br />File (...)<br />Module<br />Instance<br />View |                                                              |
| Numeric Types<br />or Numbers     | Integer (**int**)<br />Boolean (**bool**)<br />Floating-point number (**float**)<br />Complex number (**complex**) | Decimal (**decimal.Decimal**)<br />Fraction (**fractions.Fraction**)<br />Complex (?) |
| Collections:<br />**Sets**        | Frozenset (**frozenset**)<br /><br />**Mutable:**<br />Set (**set**) |                                                              |
| Collections:<br />**Sequences**   | String (**str**)<br/>Unicode<br />Bytes<br />Tuple (**tuple**)<br />Bytearray (**bytes**)<br /><br />**Mutable:**<br />List (**list**) | Named Tuples                                                 |
| Collections:<br />**Mappings**    | **Mutable:**<br />Dictionary (**dict**)                      |                                                              |
| Callables<br />Program unit types | Function<br />Generator<br />Class<br />Method (Bound)<br />Module |                                                              |
| Implementation-related types      | Compiled code (?)                                            |                                                              |

All types have generic operations that are represented as built-in functions or expressions.

Type-specific operations are method calls.

## 1. Numeric Types

In Python, numbers are not really a single object type, but a category of similar types.

### 1.1. Integers

Integers don't have fractional part, but they have unlimited size.

GET INFORMATION:

Integers have attributes (methods):

```python
x = 123
x.bit_length()
> 7
```



#### 1.1.1. Creation

##### 1.1.1.1. Create an integer by simple assignment

```python
x = -123

print(x)

> -123

type(x)

> <class 'int'>
```
##### 1.1.2. Create an integer via type convertion

From floating point number, complex number, boolean, string

Floating point number:

```python
x = int(-123.99)

print(x)

> -123
```

Boolean:

```python
x = int(True)
y = int(False)

print(x, y)

> 1 0
```

From string with integer number:

```python
x = int('123')
y = int('000')

print(x, y)

> 123 0
```

But from string with floating point number:

```python
y = int('123.999')

> ValueError: invalid literal for int() with base 10: '123.999'
```

From complex:

##### ???

From any string as a number with base:

```python
x = int('10FGH', 18)

print(x)

> 110141
```

But:

```python
x = int('10FGH', 18)

print(x)

> ValueError: invalid literal for int() with base 17: '10FGH'
```

Max base:

```python
x = int('z', 36)

print(x)

> 35

y = int('z', 37)

print(y)

> ValueError: int() base must be >= 2 and <= 36, or 0
```

From any other integer representation:

```python
int(0xb)

> 11

int(0o13)

> 11

int(0b1011)

> 11
```

#### 1... How to get know how many digits in a really big number?

```python
len(str(12345 ** 12345))

> 50510
```

### 1.2. Hexademical (hex), octal, and binary literals

This is just anothe representation of integer number.

#### 1.2.1. Create a hexademical number (2 ways). What type will you gain?

```python
x = 0x1f # Or x = 0X1F, or 0x1F ...

print(x, type(x))

> 31 <class 'int'>
```

From integer:

```python
x = hex(31)

print(x)

> 0x1f <class 'str'>
```

#### 1.2.2. Create an octal number

```python
x = 0o12 # Or x = 0O12

print(x)

> 10
```

From integer:

```python
x = oct(10)

print(x)

> 0o12
```

#### 1.2.2. Create a binary number

```python
x = 0b010101

print(x)

> 21
```

From integer:

```python
x = bin(21)

print(x)

> 0b10101 # First zero was thrown away
```

### 1.3. Floating-point numbers

Floating-point numbers (Real Number — **float**) have precision:

`1.`
`3.45`
`3.10e-10`



From scratch:

```python
x = 12.34567e3
x
> 12345.67
```

Convertion:

```python
x = float(1)
x
> 1.0
```

```python
x = float('12.34e-3')
x
> 0.01234
```



Test methods:

```python
x = 1.2
x.is_integer()
> False

y = 2.0
y.is_integer()
> True
```

Convert into fraction number type method:

```python
x = 1.2
x.as_integer_ratio()
> (5404319552844595, 4503599627370496)
```





### 1.4. Complex numbers

Complex number includes **real part** and **imaginary part**, which can be presented via integer or float number.

#### 1.4.1. Creation

##### 1.4.1.1. Creating complex number from scratch

###### How to create a complex number (2 ways)?

By assignment:

```python
x = 1 + 2.3j # Or: 1+2.3J

print(x)

> (1+2.3j)

print(type(x))

> <class 'complex'>
```

Via built-in call:

```python
x = complex(1, 2.3)

print(x)

> (1+2.3j)
```

##### 1.4.1.2. Creating via convertion

###### How to create complex number from integer?

```python
x = complex(12)
x
> (12+0j)
```

###### How to create complex number from floating-point number?

```python
x = complex(12.34)
x
> (12.34+0j)
```

### 1.5. Boolean

Boolean in Python is a part of Integer class.

```python
type(True).__base__

> int
```

What is it, boolean?

```python
type(True)
> bool
```

But:

```python
isinstance(True, bool)
> True

isinstance(True, int)
> True
```

```python
True == 1 # Has the same value
> True

True is 1 # But different objects
> False

True + 4
> 5
```

```python
# Boolean

a = True
b = False
print(type(a))
print(type(b))
print(a + b)
print(a + a)
print(b + b)
print(int(a), int(b))

print(bool(s))
print(bool(''))
> True
> False
```

```python
print(bool(33.54))
print(bool(-32.44))
print(bool(0))
```

```python
# Logic operations

print(True and False)
print(True and True)
print(False and False)

>
False
True
False
```

```python
# Logic operations

print(True or False)
print(True or True)
print(False or False)

>
True
True
False
```



## Operations

Expression operators:

- a + b, a - b
- a * b, a / b
- a >> b
- a ** b
- a & b
- ...

Built-in functions:

- pow()
- abs()
- round()

```python
print(round(8.334324234, 3))
> 8.334
```



#### Ariphmetical operations

```python
a = 4
b = 3

print(a + b, 1 - j + 2 + 3j)
> 7
print(a - b)
> 1
print(a * b)
> 12
print(a / 2)
> 2.0
print(a / b) # True division
> 1.3333333333333333
print(15 // 2) # Floor division
> 7
print(-15 // 2) # That's floor division peculiarity
> -8
print(15.0 // 2.0)
> 7
print(15 % 2)
> 1
print(3 ** 2)
> 9
print(2 ** 3.0)
> 9.0
```

Result of dividing integer always floating-point number.

### Mixed type conversion

Sum, substraction and multiplication of integer and float gives float:

```python
3 + 1.0
> 4.0
4 * 3.0
> 12.0
```

### Comparisons: normal and chained

#### What is bigger or less or equal?

It is possible to compare integer and floating-point number, boolean type is a special representation of integer 0 and 1.

```python
print(4 > 3, True < False, 3.42 <= 3, True >= 3)

> True False False False
```

#### What is equal and not equal?

```python
print(2 == 3, 2 != 5)

> False True
```

#### Compare integers in a chain

```python
print(3 < 4 < 2)

> False
```

It is equal to:

```python
print(3 < 4 and 4 < 2)

> False
```

Different type of compares:

```python
print(1 != 2 < 3)

> True
```

But be careful with Python precision:

```python
print(1.1 + 2.2 == 3.3)

> False

print(1.1 + 2.2)

> 3.3000000000000003

print(int(1.1 + 2.2) == int(3.3))

> True
```

### Bitwice Operations with Integers(!)

#### How to add zeros to the right

```python
x = 13
y = x << 4
print(x, bin(x), y, '=', bin(y))

> 13 0b1101 208 = 0b11010000
```

#### How to shring 0 and 1 from the right side

```python
x = 13
y = x >> 2
print(x, bin(x), y, '=', bin(y))

> 13 0b1101 3 = 0b11
```

#### Implement bitwise OR operation

```python
x = 10
y = 9
res = x | y
print(x, bin(x), y, bin(y), res, bin(res))

> 10 0b1010 9 0b1001 11 0b1011
```

#### Implement bitwise AND operation

```python
x = 10
y = 9
res = x & y
print(x, bin(x), y, bin(y), res, bin(res))

> 10 0b1010 9 0b1001 8 0b1000
```

## 2. Collections: SETS

### 2.1. Set

**Set** is an unordered collection of unique and immutable objects that supports operations corresponding to mathematical set theory.

Collection with numeric operations, generally considered more numeric. Example: {'item1', 'item2'}

Sets are **iterable**.

#### 2.1.1. Creating set from scratch

##### 2.1.1.1. Create an empty set

```python
S = set()
type(S)
> set
```

##### 2.1.1.2. Create using set literals

```python
S = {1, 2, 'abc'}
type(S)
> set
```

##### 2.1.1.3. Show what can be stored in set

```python
S = {1, 1.2, 'abc', (1, 2, 3), lambda x: x ** 2, int}
(1, 2, 3) in S
> True
```

##### 2.1.1.4. Create frozenset

```python
S = frozenset('abc')
type(S)
> frozenset

S
> frozenset({'a', 'b', 'c'})
```

##### 2.1.1.5. Use frozenset as an element in set

```python
S = frozenset('abc')
SS = {1, 2, S}
SS
> {1, 2, frozenset({'a', 'b', 'c'})}
```

#### 2.1.2. Creating set via conversion

##### 2.1.2.1. Create set from sequences

From string:

```python
set('abracadabra')
> {'a', 'b', 'c', 'd', 'r'}
```

From list:

```python
set([1, 2, 3, 2, 4]) # The same: set((1, 2, 3, 2, 4))
> {1, 2, 3, 4}
```

From dictionary:

```python
set({'a': 1, 'b': 2, 'c': 3, 'd': 2, 'e': 4})
> {'a', 'b', 'c', 'd', 'e'}
```

#### 2.1.3. Getting information from set

##### 2.1.3.1. Get set length

```python
len(set('abc'))
> 3
```

#### 2.1.4. Getting set content

- There is no option!

#### 2.1.5. Set in-place operations

Some operations IN PLACE

Adding new elements:

As a distinct element:

```python
x = set('abcd')
x
> {'a', 'b', 'c', 'd'}

x.add('efg') # Can add only hashable type
x
> {'a', 'b', 'c', 'd', 'efg'}
```

As intersection:

```python
x = set('abcd')
x
> {'a', 'b', 'c', 'd'}

x.update('efg')
x
> {'a', 'b', 'c', 'd', 'e', 'f', 'g'}
```

Removing one element:

```python
x = set('abcd')
x.remove('d')
x
> {'a', 'b', 'c'}
```

Logic

Difference:

```python
x = set('abcdef')
y = set('efghi')
x - y
> {'a', 'b', 'c', 'd'}

y - x
> {'g', 'h', 'i'}
```

Union:

```python
x = set('abcdef')
y = set('efghi')
x | y
> {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'}
```

```python
x = set('abcdef')
y = set('efghi')
z = x.union(y)
z
> {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'}

z = z.union(['j', 'k', 'l'])
z
> {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'}
```

Intersection:

```python
x = set('abcdef')
y = set('efghi')
x & y
> {'e', 'f'}
```

```python
x = set('abcdef')
y = set('efghi')
z = x.intersection(y)
z
> {'e', 'f'}
```

Simmetric difference (XOR):

```python
x = set('abcdef')
y = set('efghi')
x ^ y # e and f will be ommited
> {'a', 'b', 'c', 'd', 'g', 'h', 'i'}
```

Check for being subset or superset of another set:

Check if includes

```python
x = set('abc')
y = set('cdf')
x > y
> False

x < y
> False
```

```python
x = set('abc')
y = set('ac')
y < x
> True

y > x
> False
```

```python
x = set('abc')
'a' in x
> True

# But don't use with several elements

y = set('ac')
y in x
> False
```

```python
x = set('ac')
x.issubset('abcd')
> True
```

##### 2.1.5.?. Check if equivalent

```powershell
>>> set('abc') == set('bca')
True
```

#### 2.1.6. Usage

In loops (unordered)

```python
x = set('abcd')
for i in x:
    print(i, end = ' ')
    
> d a b c
```

Ordered

```python
x = set('abcd')
for i in sorted(x):
    print(i, end = ' ')
    
> a b c d
```

Use sets to compare lists

```python
L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1]
L1 == L2
> False

set(L1) == set(L2)
> True

sorted(L1) == sorted(L2)
> True
```

```python
L1, L2 = [1, 2, 3, 5, 4], [2, 5, 3, 3, 2, 2, 4, 1]
set(L1) == set(L2)
> True

sorted(L1) == sorted(L2)
> False
```

#### 2.1.7. Set comprehensions

```python
S = {x for x in 'abc'}
S
> {'a', 'b', 'c'}
```

**Important!** But remember, order is not guaranteed.

USAGE

Filter out duplicates

Isolate differences

Performing order-neutral equality tests

## 3. Collections: SEQUENCES

### 3.1. String

Immutable sequences.

You can change part of the string only assigning it to another string or converting it to bytearray or list and back.



```python
# Type of String (both are 'str')

print(type('abc'))
print(type(u'abc'))
```



#### 3.1.1. Creating string

##### 3.1.1.1. From scratch

###### A. How to create an empty string?

```python
s = ''
type(s)
> str
```

###### B. How to create not empty string?

```python
s = 'abc'
s
> 'abc'

print(s)
> abc
```

##### 3.1.1.2. Via convertion

###### A. How to create string from integer?

```python
str(123)
> '123'
```

###### B. How to create string from floating-point number?

```python
str(123.40)
> '123.4'

str(1.234e10)
> '12340000000.0'
```

###### C. How to create string from complex number?

```python
str(2-4j)
> '(2-4j)'
```

##### 3.1.1.3. ???? As operations result ????

Link to not in-place operations... ???? insert link

#### 3.1.2. Some string features

##### 3.1.4. Quotes

###### A. What kind of quotes can be used (3 kinds)?

Single quotes:

```python
s = 'abc "def"'
s
> 'abc "def"'
```

Double quotes:

```python
s = "abc 'def'"
s
> "abc 'def'"
```

Triple quotes (1):

```python
s = '''This is an example
of a multiline string
with triple quotes...'''
s
>'This is an example\nof a multiline string\nwith triple quotes...'

print(s)
> This is an example
of a multiline string
with triple quotes...
```

**Attention!** There is a **\n** new line code in the string in Jupyter console.

Tripple quotes (2):

```python
s = """This is
another example..."""
s
> 'This is\nanother example...'

print(s)
> This is
another example...
```

###### B. Show alternative way of creating multiple line string

```python
s = (
  'This is an example\n' # This comment will be suppressed
  'of a multiline string')
print(s)
> This is an example
of a multiline string
```

###### C. Show difference between PRINT and REPR

```python
print(str('abc'), repr('abc'))
> abc 'abc'
```

##### 3.1.5. Backslash Characters

Backslashes are used to insert **escape sequences** — special character codings.

###### A. Show difference between print and Jupiter console?

```python
s = 'ab\ncd'
s
> 'ab\ncd'

print(s)
>
ab
cd

len(s)
> 5
```

###### B. Give as many examples of backslash characters as you can

```python
print('abc\ndef') # New line
print('abc\\def') # Backslash
print('abc\'def') # Single quote
print('abc\"def') # Double quote
print('abc\adef') # Bell
print('abc\fdef') # Formfeed ???
print('abc\tdef') # Horizontal tab
print('abc\vdef') # Vertical tab ????
print('abc\bdef') # Backspace
print('abc\rdef') # Carriage return

> abc
def
abc\def
abc'def
abc"def
abcdef
abcdef
abc	def
abcdef
abdef
def
```

###### C. Give examples of different encoding formates with backslash

```python
# Character with HEX value HH (exactly 2 digits)
# https://www.rapidtables.com/convert/number/hex-to-ascii.html
print('Dollar sign in HEX: \x24')

# Character with octal value ooo (up to 3 digits)
# http://www.unit-conversion.info/texttools/octal/
print('Dollar sign in OCT: \044')

# Unicode character with 16-bit and 32-bit hex value
# https://www.branah.com/unicode-converter 
print('Dollar sign in UNICODE-16: \u0024') 
print('Dollar sign in UNICODE-32: \U00000024')

>

Dollar sign in HEX: $
Dollar sign in OCT: $
Dollar sign in UNICODE-16: $
Dollar sign in UNICODE-32: $
```

##### 3.1.6. Raw string

###### A. Create a simple raw string

```python
s = r'ab\ncd'
print(s)
> ab\ncd

len(s)
> 6

s = r'C:\\file.txt'
```

#### 3.1.3. Getting information from string

##### 3.1.3.1. Get string length

###### How to get know length of the string?

```python
s = 'abc\ndef'
len(s)
> 6

# Backslash character wasn't taken into account
```

##### 3.1.3.2. String content tests

###### How to check if element is in the string?

```python
s = 'This is an example of the string'
'i' in s
> True

'is' in s
> True

'foo' in s
> False
```

###### .isalpha()

Content test (only characters).

```powershell
>>> 'abcd'.isalpha()
True
>>> 'abcd%4'.isalpha()
False
```

###### .isdigit()

Content test (only numbers).

```powershell
>>> 'abc123'.isdigit()
False
>>> '123'.isdigit()
True
>>> '123.12'.isdigit()
False
```

##### 3.1.3.3. Find pattern position

Find offset of 1st appearance:

```python
s = 'This is an example of the string'
s.find('is')
> 2
```

Find offset of appearance after specific offset:

```python
s = 'This is an example of the string'
s.find('i', 9)
> 29
```

.find()

Returns the offset (number) of the passed-in substring. It returns **-1** if substring is not present in the string.

```powershell
>>> S = 'abcd'
>>> S.find('bc')
1
```

##### 3.1.3.4. How manu times pattern occures in string

###### How many times pattern occures in full string?

```python
S = 'abcdef abcde abcd abc ab a'
S.count('de')
> 2
```

###### How many times pattern occures in the string starting from specific offset in the string?

```python
S = 'abcdef abcde abcd abc ab a'
S.count('cd', 6)
> 2
```

###### How many times pattern appears in the string starting from and finishing befor specific offset in the string?

```python
S = 'abcdef abcde abcd abc ab a'
S.count('cd', 6, 12)
> 1
```

##### 3.1.3.5. Change representation (encoding)

###### Get binary value of character

Function returns the binary value of char from ASCII:

```python
ord('$')
> 36

ord('\n')
> 10
```

###### Get character from binary

```python
chr(36)
> '$'

chr(10)
> '\n'
```

###### Get next character from given

```python
c = 'D'
chr(ord(c) + 1)
> 'E'
```

#### 3.1.4. Gettting content of the string

##### 3.1.4.1. Indexing and slicing

###### Get character at specific offset from begining of the string

```python
s = 'abcdef'
s[3]
> d
```

###### Get character at specific offset from the END of the string

Negative indexing

```python
s = 'abcdef'
s[-3]
> d
```

It's the same as:

```powershell
>>> S[len(S)-1]
'd'
```

Get the second-to-last item from the end:

```powershell
>>> S[-2]
'c'
```

###### Get slice from specific offset to another specific offset

General form **X[A:B]** means get everything in **X** from offset **A** up to but not including offset **B**.

Get everything from the **3rd** position up to **5th**:

```python
s = 'abcdef'
s[2:4]
> cd
```

###### Get slice from beginning to a specific offset (2 cases)

```python
s = 'abcdef'
s[:4]
> abcd
```

```python
s = 'abcdef'
s[:-2]
> abcd
```

###### Get everything but the last

```powershell
>>> S[:-1]
'abc'
```

###### Get slice from a specific offset to the end

Get everything from the **4th** position (offset):

```python
s = 'abcdef'
s[2:]
> cdef
```

Or counting from the end:

```python
s = 'abcdef'
s[-2:]
> ef
```



###### Get slice of every odd element in the string

```python
s = 'abcdef'
s[::2]
> ace
```

###### Get everything

Get everything:

```powershell
>>> S[:]
'abcd'
```

###### Invert string using slicing

```python
s = 'abcdef'
s[::-1]
> fedcba
```

###### Show alternative (object) slice syntax

```python
s = 'abcdef'
s[slice(None,-2,2)]
> ac
```

#### 3.1.5. Not in-place operations

##### 3.1.3.1. Explicit concatenation

Always returns a new string.

```powershell
>>> S = 'abcd'
>>> S + 'ef'
'abcdef'
```

##### 3.1.3.2. Implicit concatenation on creation

```powershell
>>> S = 'ab' 'cd'
>>> S
'abcd'
```

##### ???? 3.1.3.1. Concatenation (2 examples)

```python
s = 'abc' + 'def'
print(s)
> abcdef
```

String implicit concatenation

```python
s = "This is " 'an example' " of implicit concatenation"
s
> 'This is an example of implicit concatenation'
```

Some other example (clarify operation name):

```python
s = 'abc'
s += 'def'
s
> 'abcdef'
```

##### 3.1.3.3. Repetition

```python
s = 'abc' * 3
print(s)
> abcabcabc
```

##### ???? 4. Repetition

```powershell
>>> S = 'abcd'
>>> S * 3
'abcdabcdabcd'
```

### 

##### 3.1.3.4. Joining

```python
L = ['a', 'b', 'c']
S = '-'.join(L)
S
> 'a-b-c'
```

##### .replace()

Returns a new string with replaced substrings (doesn't change a prior string).

```powershell
>>> S = 'abcd'
>>> S.replace('bc', 'BC')
'aBCd'
```

##### .replace()

Returns a new string with replaced substrings (doesn't change a prior string).

```powershell
>>> S = 'abcd'
>>> S.replace('bc', 'BC')
'aBCd'
```

##### 

##### .lstrip()

Remove on the left side.

##### .strip()

Remove on both sides.

##### .rstrip()

Remove whitespace characters on the right side.

`>>> string = ' text\n'`

`>>> len(string)`

`6`

`>>> string.rstrip()`

`' text'`

##### .upper()

Retuons a new string, a copy of prior string but all characters converted into uppercase.

```powershell
>>> S = 'abcd'
>>> S.upper()
'ABCD'
```

##### 3.4.1. Replacement

##### 3.4.1.1. Give example of replacement

```python
s = 'abcdef'
S = s.replace('cd', 'CD')
S
> 'abCDef'

s
> 'abcdef'
```

##### 3.4.2. Differents operations

##### 3.4.2.1. How to capitalize first letter in the string?

```python
'abcde'.capitalize()
> 'Abcde'
```

##### 3.4.2.2. How to convert all characters to upper case?

```python
'Abcde'.upper()
> 'ABCDE'
```

##### 3.4.2.3. How to convert all characters to lower case?

```python
'Abcde'.lower()
> 'abcde'
```

The same but stronger

```python
'Abcde'.casefold()
> 'abcde'
```

##### 3.4.3. Splitting a string into a list (convertion)

```python
S = 'ab cd ef'
L = S.split()
L
> ['ab', 'cd', 'ef']
```

```python
S = 'ab, cd, ef'
L = S.split(', ')
L
> ['ab', 'cd', 'ef']
```

##### .split()

Returns a new list of strings, gathered after a prior string was splitted on a delimiter (doesn't change a prior string):

```powershell
>>> S = 'a, b, cd'
>>> S.split(', ')
['a', 'b', 'cd']
```

#### 

#### 3.1.5. String formating

##### 3.1.5.1. Expression

###### Show expression with one element

```python
'abc %d def' % 123
> 'abc 123 def'
```

###### Show expression with two or more elements

```python
'That is %d %s bird!' % (1, 'dead')
> 'That is 1 dead bird!'
```

###### Show different data types

As string:

```python
'String: %s %s %s %s' % ('abc', 123, 12.34, [1, 2, 3])
> 'String: abc 123 12.34 [1, 2, 3]'
```

As string with repr, shows string in single quotes:

```python
'String (repr): %r' % 'abc'
> "String (repr): 'abc'"
```

As character:

```python
'Character: %c %c %c' % ('a', 1, True)
> 'String: a \x01 \x01'
```

As decimal:

```python
'Decimal: %d %d %d' % (123, 123.4, True)
> 'Decimal: 123 123 1'
```

As integer:

```python
'Integer: %i %i %i' % (123, 123.45, True)
> 'Integer: 123 123 1'
```

As **octal** integer:

```python
'Octal integer: %o %o' % (123, True)
> 'Octal integer: 173 1'
```

As **hexademical** integer:

```python
# Lowercase

'Hexademical integer: %x %x' % (123, True)
> 'Hexademical integer: 7b 1'

# Uppercase

'Hexademical integer: %X %X' % (123, True)
> 'Hexademical integer: 7B 1'
```

As **floating point** with exponent:

```python
# Lowercase

'Floating point with exponent: %e' % 123.456
> 'Floating point with exponent: 1.234560e+02'

# Uppercase

'Floating point with exponent: %E' % 123.456
> 'Floating point with exponent: 1.234560E+02'
```

As **floating point** decimal:

```python
# Lowercase

'Floating point decimal: %f' % 123.456
> 'Floating point decimal: 123.456000'

# Uppercase ??????

'Floating point decimal: %F' % 123.456
> 'Floating point decimal: 123.456000'
```

As **floating point** e (E) or f (F):

```python
# Lowercase

'Floating point decimal: %g' % 123.456
> 'Floating point decimal: 123.456'

# Uppercase

'Floating point decimal: %G' % 123.456
> 'Floating point decimal: 123.456'
```

###### How to specify reserved positions for digit?

```python
'abc %12d def' % 123
> 'abc          123 def'

'abc %-12d def' % 123
> 'abc 123          def'

'abc %012d def' % 123
> 'abc 000000000123 def'

'abc %2d def' % 12345678
> 'abc 12345678 def'

'abc %+d %12+d %-12+d def' % (-123, 123, -123, 123)
> 'abc -123 +123 def'
```

###### Sign of digit

```python
'%+d' % 123
> '+123'

'%+12d' % 123
> '        +123'

'%+012d' % 123
> '+00000000123'

'%-+12d' % 123
> '+123        '
```

###### Precision

```python
'%.2f' % 123.45678
> '123.46'

'%.12f' % 123.45678
> '123.456780000000'

'%12.2f' % 123.45678
> '      123.46'

'%012.2f' % 123.45678
> '000000123.46'
```

##### 3.1.5.2. Dictionary based formating

```python
'%(x)d / 3 %(eql)s %(rslt)+4.2f' % {'x': 1, 'eql': '=', 'rslt': 1 / 3}
> '1 / 3 = +0.33'
```

##### 3.1.5.3. Formating method

By automatic position:

```python
'{}, {} and {}'.format(2, 3, 1)
> '2, 3 and 1'
```

By position:

```python
'{1}, {0} and {2}'.format(2, 3, 1)
> '3, 2 and 1'
```

By keyword and position:

```python
'{0} / 4 {eql} {square}'.format(3, eql = '=', square = 1 / 4)
> '3 / 4 = 0.25'
```

Advanced data:

```python
class One: pass

ins = One()
ins.brand = 'Apple'

'{system.brand} {comp[OS]} {comp[RAM]}'.format(system = ins, comp = {'OS': 'MacOS', 'RAM': '8Gb'})
> 'Apple MacOS 8Gb'
```

```python
S = 'abcdef'
'The first letter is \'{0[0]}\' and the last \'{0[5]}\''.format(S)
> "The first letter is 'a' and the last 'f'"
```

##### 3.1.5.4. Advanced examples

???

### 3.2. Tuple

Immutable sequances.

#### 3.2.1. Creation

##### 3.2.1.1. Create tuple from scratch

###### How to create an empty tuple?

```python
T = ()
type(T)
> tuple
```

###### How to create one element tuple?

If tuple have only one item, it requires a trailing comma:

```python
T = ('a',)
T
> ('a',)

type(T)
> tuple

S = ('a')
S
> 'a'

type(S)
> str
```

###### How to create tuple with arbitrary elements (2 ways)?

Full form:

```python
T = (1, 'a', 1.23, True, [1, 2])
T
> (1, 'a', 1.23, True, [1, 2])
```

###### How to create a tuple in a laconic form?

Parentheses enclosing a tuple's items can usually be omitted:

```python
T = 1, 2, 3
T
> (1, 2, 3)

type(T)
> tuple
```

###### How to create nested tuples?

```python
T = (1, 2, (3, 4))
T
> (1, 2, (3, 4))
```

##### 3.2.1.2. Create tuple from other objects (conversion)

###### How to create a tuple from sequences?

From string:

```python
T = tuple('abc')
T
> ('a', 'b', 'c')
```

From list:

```python
T = tuple([1, 2, 3])
T
> (1, 2, 3)
```

From dictionary:

```python
T = tuple({'a': 1, 'b': 2, 'c': 3})
T
> ('a', 'b', 'c')
```

###### How to create a tuple from range?

```python
T = tuple(range(4))
T
> (0, 1, 2, 3)
```

#### 3.2.2. Getting information

##### 3.2.2.1. Get tuple length

###### How to get know tuple length?

```python
T = 1, 2, 3
len(T)
> 3
```

##### 3.2.2.2. Test membership

###### How to check if element is in a tuple?

```python
T = 1, 2, 3
2 in T
> True
```

##### 3.2.2.3. Content investigation

###### How to find offset (index) of some element?

Offset of the 1st appearance:

```python
T = 1, 2, 3, 3, 1, 2, 4, 3, 2, 4
T.index(2)
> 1
```

Offset of the appearance after (including) offset:

```python
T = 1, 2, 3, 3, 1, 2, 4, 3, 2, 4
T.index(1, 3) # Where placed 1 firstly after offset 3
> 4
```

###### How to count element appearance?

```python
T = 1, 2, 3, 3, 1, 2, 4, 3, 2, 4
T.count(3)
> 3
```

#### 3.2.3. Getting content

##### 3.2.3.1. Indexing

###### Get element by index

```python
T = (1, 2, 3)
T[1]
> 2
```

##### 3.2.3.2. Slicing

###### Get slice of the tuple

```python
T = 1, 2, 3, 4, 5
T[1:4]
> (2, 3, 4)
```

#### 3.2.4. Operations

###### What arithmetic operations are supported by tuples?

A. Concatenation (addition):

```python
(1, 2, 3) + (3, 4)
> (1, 2, 3, 3, 4)

(1, 2) + [2, 3]
> TypeError: can only concatenate tuple (not "list") to tuple
```

**B. Substraction is not supported!**

C. Repetition (multiplication):

```python
(1, 2) * 3
> (1, 2, 1, 2, 1, 2)

(1, 2) * 3.0
> TypeError: can't multiply sequence by non-int of type 'float'
```

**D. Division is not supported!**

#### 3.2.5. Representation

##### 3.2.5.1. Sorting

###### How to sort tuple (2 ways)?

With converting to list and back:

```python
T = 3, 1, 2
L = list(T)
L.sort()
tuple(L)
> (1, 2, 3)
```

With built-in **sorted(...)** function:

```python
T = 3, 1, 2
tuple(sorted(T)) # sorted returns a list
> (1, 2, 3)
```

#### 3.2.6. Modifying tuples

###### How tuple can be modified?

Tuples are immutable only on the top-level.

```python
T = 1, ['a', 'b'], 2
T[1] = 'ab'
> TypeError: 'tuple' object does not support item assignment

T[1].append('c')
T
> (1, ['a', 'b', 'c'], 2)
```

### 3.3. List

```python
Legend:
(*) — required parameter
```

## Questions to Rewise

[Introduction](#introduction)

1. What are lists in Python data types classification?
2. How are they realized technically?

OPERATIONS

[Creation](#create-list)

3. Point out all list creating approaches.
4. Create an empty list using literals.
5. Create a list with arbitrary items using literals.
6. Create a matrix using literals.
7. Create a list from string, set, dictonary, tuple, range, map
8. Create a list using expression.
9. Create a matrix using expression.
10. Create a list of matrix row sums: two different approaches.

[Copying](#copy-list)

11. Copy list: three different methods.

[Get some information](#get-info)

12. Derive list length.
13. Check if the element is in the list.
14. Find index of the element by value.
15. Count how many time exact value occure in the list.
16. Count sum of all elements of the list.

[Fetch content from the list](#get-content)

17. Get any element from the list by it's index.
18. Get the element of the matrix.
19. Get the last element from the list.
20. Get the prelast elemnt form the list.
21. Get elements from A offset to B offset from the list.

[Modify content](#modify)

22. Concatenate two lists.
23. Repeat one list.
24. Assign new value to the list item.
25. Change few items in the list.
26. Change few items in the list using period.
27. Insert items in the list (center).
28. Insert items in front of the list.
29. Add one item to the end of the list: several approaches
30. Add several items to the end of the list: several approaches
31. Assign one part of the list to another.
32. Delete one item by index: several approaches.
33. Delete last item: several approaches.
34. Delete one item by its value.
35. Delete several items by its value.
36. Delete all items in the list.
37. Sort list with only lower case: several approaches.
38. Sort list with lower and upper case: several approaches.
39. Sort list with reversing it.
40. Reverse list: several approaches.

## Introduction

Lists are:

- Ordered collections (**mutable sequence**) of arbitrary objects:
- Collections → Sequences → Mutable → Lists
- Accessed by offset
- Arbitrarily nestable

Technically, lists contain zero or more references to other objects like arrays of pointers (addresses).

## Operations

### Create List

Create an empty list:

```python
>>> L = []
```

Create list with arbitrary elements:

```python
>>> L = [12.3, 'abc', True, [1, 2]]
```

Create 2 dimensional list (matrix):

```python
>>> M = [[1, 2, 3],
         [4, 5, 6],
         [7, 8, 9]]
>>> M
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

Create list from **sequence type element** with **«list(x*)»** method, where **x** — any sequence type element:

```python
>>> list('abc')							# List from string
['a', 'b', 'c']
>>> list({1,2})							# List from set
[1, 2]
>>> list({1: 'a', 2: 'b'})	# List from dictionary, only keys
[1, 2]
>>> list((1, 2))						# List from tuple
[1, 2]
>>> list(range(3))				  # List from range
[0, 1, 2]
>>> list(map(sum, [[1, 2], [3, 4]]))
[3, 7]
```

Create list with **list comprehension expressions**:

```python
>>> [x ** 2 for x in range(4)]
[0, 1, 4, 9]
```

### Copy List

Create list via **copying** existing list:

##### .copy()

Returns a list, full copy of the original list:

```python
>>> L = [1, 2, 3]
>>> L.copy()
[1, 2, 3]
```

##### Copy via «list(x*)» method

```python
>>> L = [1, 2, 3]
>>> K = list(L)
>>> K
[1, 2, 3]
```

Get full copy via slicing:

```python
>>> L = [1, 2, 3]
>>> K = L[:]
>>> K
[1, 2, 3]
```

### Get info

#### Get Length

Method **«len(x*)»** returns integer.

```python
>>> len([1, 2, 3])
3
```

#### Test membership

Statement **«x* in y*»** returns boolean, where **x** — any value, and **y** — any sequence:

```python
>>> 1 in [1, 2, 3]
True
```

#### Search

##### .index(value*)

Returns integer (position), required **value** — value under search.

```python
>>> L = [1, 2, 3]
>>> L.index(3)
2
```

#### Count

##### .count(value*)

Returns integer (count of occurenecies), required **value** — value under search.

```python
>>> L = [1, 1, 2, 2, 1, 3]
>>> L.count(1)
3
```

#### Sum

##### .sum(sequence of numbers*)

```python
>>> L = [1, 2, 3]
>>> sum(L)
6
```

But:

```python
>>> L = [[1, 2], [3, 4]]
>>> sum(L)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'list'
```



### Get content

#### Index

Indexing always returns item value (any type).

```python
>>> L = [1, 'a', True]
>>> L[2]
True
```

Indexing off the end of a list is always a mistake:

```python
>>> L = [1, 2, 3]
>>> L[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

#### Index of index

```python
>>> matrix = [[1, 2],
							[3, 4]]
>>> matrix[1][0]
3
```

#### Negative index

Get the last item in the list

```python
>>> L = [1, 2, 3]
>>> L[-1]
3
```

Equivalent to:

```python
>>> L[len(L) - 1]
3
```

Get the second-to-last item from the end:

```python
>>> L[-2]
2
```

#### Slice

General form **X[a:b]** — everything in **X** from offset **a** up to but not including offset **b**.

Slicing a list always returns a new list.

```python
>>> L = [1, 2, 3, 4]
>>> L[1:-1]
[1, 2, 3]
```

Get each odd element from the 2nd element to the end of the list:

```python
>>> L = [1, 2, 3, 4, 5]
>>> L[2::2]
[3, 5]
```

### Modify

#### Concatenation

Returns a new list (doesn't change a prior list).

```python
>>> L = [1, 2, 3]
>>> L + [4, 5, 6]
[1, 2, 3, 4, 5, 6]
>>> L
[1, 2, 3]
```

#### Repetition

Returns a new list (doesn't change a prior list).

```python
>>> L = [1, 2, 3]
>>> L * 2
[1, 2, 3, 1, 2, 3]
>>> L
[1, 2, 3]
```

Ariphmetical operations:

```python
L = [1, 2]
L = L + [3, 4]
L
> [1, 2, 3, 4]

L += [5, 6]
L
> [1, 2, 3, 4, 5, 6]
```

### Modify (in place)

#### Index assignment

In place change.

```python
>>> L = [1, 2, 3]
>>> L[1] = 'abc'
>>> L
[1, 'abc', 3]
```

You can't assign to an unexisting item.

```python
>>> L[3] = 'abc'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
```

#### Slice assignment

In place change.

Delete and insert slices, number of items inserted doesn't have to match the number of items deleted.

Change one item:

```python
>>> L = [1, 2, 3]
>>> L[0:1] = ['abc']
>>> L
['abc', 2, 3]
```

Change few items, assign another list:

```python
>>> L = [1, 2, 3]
>>> L[0:2] = ['abc']
>>> L
['abc', 3]
```

**Attention!** Be carefull assigning any sequence:

```python
>>> L = [1, 2, 3]
>>> L[0:1] = 'ab'
>>> L
['a', 'b', 2, 3]
```

**Using period**

```python
>>> L = [1, 2, 3, 4, 5]
>>> L[::2] = 'abc'
>>> L
['a', 2, 'b', 4, 'c']
```

**Attention!** This demands matching of deleted and inserted number of items.

```python
>>> L = [1, 2, 3, 4, 5]
>>> L[::2] = 'ab'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: attempt to assign sequence of size 2 to extended slice of size 3
```

**Insertion (replace nothing)**

Insert before second element:

```python
>>> L = [1, 2, 3]
>>> L[1:1] = ['abc']
[1, 'abc', 2, 3]
```

Insert in the begining of the list:

```python
>>> L = [1, 2, 3]
>>> L[:0] = [0]
>>> L
[0, 1, 2, 3]
```

Insert in the end of the list:

```python
>>> L = [1, 2, 3]
>>> L[len(L):] = [4, 5]
>>> L
[1, 2, 3, 4, 5]
```

**Deletion (insert nothing)**

Delete second element:

```python
>>> L = [1, 2, 3]
>>> L[1:2] = []
>>> L
[1, 3]
>>> L[1:2] = ''
[1]
```

**Self assignment**

This works fine:

```python
>>> L = [1, 2, 3, 4]
>>> L[0:2] = L[1:3]
>>> L
[2, 3, 3, 4]
```

#### Type-specific methods

##### .append(value*)

Add ONE item in the end of the list (in place):

```python
>>> L = [1, 2, 3]
>>> L.append('abc')
>>> L
[1, 2, 3, 'abc']
```

##### .extend(list*)

Add MULTIPLE items in the end of the list (in place):

```python
>>> L = [1, 2, 3]
>>> L.extend(['abc'])
>>> L
[1, 2, 3, 'abc']
```

**Attention!** But be carefull using iterable items:

```python
>>> L = [1, 2, 3]
>>> L.extend('abc')
>>> L
[1, 2, 3, 'a', 'b', 'c']
```

##### .insert(index*,  value\*)

Insert item at an arbitrary position:

```python
>>> L = [1, 2, 3]
>>> L.insert(1, 'abc')
>>> L
[1, 'abc', 2, 3]
```

##### .pop(x)

- **x** — index of item to delete (not necessary).

Delete ONE item by its offset (in place), returns deleted item value:

```python
>>> L = [1, 2, 3]
>>> L.pop(2)
3
>>> L
[1, 2]
```

Delete last in the list (by default):

```python
>>> L = [2, 1, 2, 3, 2]
>>> L.pop()
```

##### «del» statement

Delete item by offset:

```python
>>> L = [1, 2, 3]
>>> del L[1]
>>> L
[1, 3]
```

Delete range of items:

``` python
>>> L = [1, 2, 3, 4, 5, 6]
>>> del L[2:4]
>>> L
[1, 2, 5, 6]
```

Delete every even element:

```python
>>> L = [1, 2, 3, 4, 5, 6]
>>> del L[1::2]
>>> L
[1, 3, 5]
```

##### .remove(index*)

Remove a given item by value (only FIRST occurrency of the value):

```python
>>> L = [1, 2, 2, 3]
>>> L.remove(2)
>>> L
[1, 2, 3]
```

Works fine even if you want to remove list from list.

Doesn't work when you try to remove nested element.

```python
>>> L = [[1, 2], [3, 4]]
>>> L.remove([2])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: list.remove(x): x not in list
```

##### .clear()

No arguments.

Delete all items:

```python
>>> L = [1, 2, 3]
>>> L.clear()
>>> L
[]
```

##### .sort(key = *func*, reverse = *bool*)

Changes list in place.

```python
>>> L = ['def', 'gih', 'abc']
>>> L.sort()
>>> L
['abc', 'def', 'gih']
```

**Important!** Can't sort items with different types (but **bool**, **int** and **float** are considered as a one type).

```python
>>> L = [12, 'abc', 14, 'def']
>>> L.sort()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '<' not supported between instances of 'str' and 'int'
```

With key:

```python
>>> L = ['abc', 'ABC', 'bcd', 'BCD']
>>> L.sort()
>>> L
['ABC', 'BCD', 'abc', 'bcd']
>>> L = ['abc', 'ABC', 'bcd', 'BCD']
>>> L.sort(key = str.lower)
>>> L
['abc', 'ABC', 'bcd', 'BCD']
```

Using reverse:

```python
>>> L = ['abc', 'cde', 'bcd']
>>> L.sort(reverse = True)
>>> L
['cde', 'bcd', 'abc']
```

##### .sorted(x*, key = *func*, reverse = *bool*)

Returns new list with sorted elements.

```python
>>> L = ['BCD', 'abc', 'bcd', 'ABC']
>>> sorted([x.lower() for x in L])
['abc', 'abc', 'bcd', 'bcd']
>>> L
['BCD', 'abc', 'bcd', 'ABC']
```

```python
>>> L = ['BCD', 'abc', 'bcd', 'ABC']
>>> sorted(L, key = str.lower)
['abc', 'ABC', 'BCD', 'bcd']
>>> L
['BCD', 'abc', 'bcd', 'ABC']
```

##### .reverse()

Changes list in place.

```python
>>> L = [12, 'abc', 14, 'def']
>>> L.reverse()
>>> L
['def', 14, 'abc', 12]
```

##### .reversed(x*)

Returns iterator object, need to be wrapped with **list(x*)** method:

```python
>>> L = [1, 2, 3]
>>> list(reversed(L))
[3, 2, 1]
```







## 6. Dictionary

Dictionaries in Python are mutable mappings.

Any type of data in keys and in items.

### 6.1. Creation

#### 6.1.1. Create dictionary from scratch

##### 6.1.1.1. How to create an empty dictionary (2 ways)?

```python
D = {}
type(D)
> dict
```

```python
D = dict()
type(D)
> dict
```

##### 6.1.1.2. How to create a dictionary without values?

```python
D = dict.fromkeys([1, 2])
D
> {1: None, 2: None}
```

##### 6.1.1.3. How to create a dictionary with several keys and the same values?

```python
D = dict.fromkeys([1, 2], 'abc')
D
> {1: 'abc', 2: 'abc'}
```

##### 6.1.1.3. Show different ways of creating dictionary via assignment (3 ways)

Using curly-braces literal form:

```python
D = {'a': 1, 2: 'b'}
```

Using **dict(...)** built-in function:

```python
D = dict(arg_1 = 1, arg_2 = 'b')
D
> {'arg_1': 1, 'arg_2': 'b'}
```

Using **dict(...)** function with zipping:

```python
D = dict([(1, 'a'), (2, 'b')])
D
> {1: 'a', 2: 'b'}
```

Using **dict(...)** and **zip(...)** functions:

```python
keys = (1, 2)
values = ('a', 'b')
D = dict(zip(keys, values))
D
> {1: 'a', 2: 'b'}
```

Using dictionary comprehension expression:

```python
D = {key: val for key, val in [(1, 'a'), (2, 'b')]}
D
> {1: 'a', 2: 'b'}
```

##### 6.1.1.4. Create dictionary with nested elements

```python
D = {
  1: 1,
  'abc': {
    'i': 11,
    'k': [0, 1, 2]
  },
  0.2: 'abc',
  (1, 2): '12',
  1+3j: 12
}
```

##### 6... What can be a key?

Any type of data in keys and in items.

{(1, 2, 3): [1, 2, 4]} — dictionary, where a key is a tuple, and an item is a list.

**Attention!** You can use only hashable datatypes as a key:

- Integer number
- Floating-point number
- Complex number
- String
- Tuple

#### 6.1.2. Create dictionary from other objects (convertion)



Create list from **sequence type element** with **«list(x*)»** method, where **x** — any sequence type element:

##### .copy()

##### Copy via «list(x*)» method

### 6.2. Getting information

#### 6.2.1. Get dictionary length

##### 6.2.1.1. How to get dictionary lenght (count of keys)?

```python
D = {'a': 1, 'b': [1, 2], 'c': 3}
len(D)
> 3
```

#### 6.2.2. Test membership

##### 6.2.2.1. How to check if something is a key in a dictionary?

Dictionary **in** membership expression allows us to query the existence of a key (and ONLY KEY).

```python
D = {'a': 1, 'b': 2, 'c': 3}
'a' in D
> True

'a' in D.keys()
> True
```

##### 6.2.2.2. How to check if something is a value in a dictionary?

```python
D = {'a': 1, 'b': 2, 'c': 3}
1 in D.values()
> True

1 in D
> False
```

#### How to avoid error accessing nonexistent key?

There are a variety of ways to avoid accessing nonexistent keys in the dictionfries.

##### «in» method with «if» statement

```powershell
>>> D = {'name': 'Bob', 'age': 45}
>>> if not 'sex' in D:
...    print('missing')
...
missing
```

##### «get» method with default value

```powershell
>>> D = {'name': 'Bob', 'age': 45}
>>> D.get('sex', 0)
0
>>> D.get('name', 0)
'Bob'
```

##### «if / else» expression form

```powershell
>>> D = {'name': 'Bob', 'age': 45}
>>> D['sex'] if 'sex' in D else 0
0
```



#### Search

##### .index(value*)

#### Count

##### .count(value*)

#### Sum

##### .sum(list of numbers*)

### 6.3. Getting content (fetch items)

#### 6.3.1. Get value by key (fetching)

##### 6.3.1.1. How to get value by key (2.5 ways)?

Using indexing:

```python
D = {'a': 1, 'b': {1: 'b1', 2: 'b2'}}
D['a']

> 1

D['b'][1]

> 'b1'
```

Using **get(...)** method:

```python
D = {'a': 1, 'b': {1: 'b1', 2: 'b2'}}
D.get('a')
> 1

print(D.get('c')) # None can't be output in Jupyter terminal without PRINT
> None
```

Using **get(...)** method with default value:

```python
D = {'a': 1, 'b': {1: 'b1', 2: 'b2'}}
D.get('c', 88)
> 88
```

#### 6.3.2. Get keys

##### 6.3.2.1. How to get all dictionary keys?

```python
D = {'a': 1, 'b': 2, 'c': 3}
K = list(D)
K
> ['a', 'b', 'c']
```

```python
D = {'a': 1, 'b': 2, 'c': 3}
K = [x for x in D]
K
> ['a', 'b', 'c']
```

Method .keys() returns iterable

```python
D = {'a': 1, 'b': 2, 'c': 3}
K = D.keys()
K

> dict_keys(['a', 'b', 'c'])

list(K)
> ['a', 'b', 'c']
```

#### 6.3.3. Get values

##### 5.3.3.1. How to get dictionary values?

Method .values() return iterable

```python
D = {'a': 1, 'b': 2, 'c': 3}
V = D.values()
V
> dict_values([1, 2, 3])

list(V)
> [1, 2, 3]
```

#### 5.3.4. Get key-value pairs

##### 5.3.4.1. How to get dictionary key-value pairs?

Method .items() return iterable:

```python
D = {'a': 1, 'b': 2, 'c': 3}
I = D.items()
I
> dict_items([('a', 1), ('b', 2), ('c', 3)])
```

### 5.4. Modify dictionary

#### Concatenation

#### Repetition

### 5.5. Modify dictionary in place

#### 5.5.1. Set value by key (mapping operation)

New elements can be created via assignment to an unexistent item.

##### 5.5.1.1. How to assign value to a specific element?

Index assignment:

```python
D = {'a': 1, 'b': 2, 'c': 3}
D['c'] = [1, 2, 3]
D
> {'a': 1, 'b': 2, 'c': [1, 2, 3]}
```

##### 5.5.1.2. How to add a new entry into dictionary?

Index assignment:

```python
D = {'a': 1, 'b': 2, 'c': 3}
D['d'] = 4
D
> {'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

##### 5.5.1.3. How to assign and add new entry in one action?

```python
D = {'a': 1, 'b': 2, 'c': 3}
D.update({'c': 123, 'd': 4, 'e': 5})
D
> {'a': 1, 'b': 2, 'c': 123, 'd': 4, 'e': 5}
```

##### 5.5.1.3. How to delete specific element (2 ways)?

Using **del** statement:

```python
D = {'a': 1, 'b': 2, 'c': 3}
del D['c']
D
> {'a': 1, 'b': 2}
```

Using **pop(...)** method:

```python
D = {'a': 1, 'b': 2, 'c': 3}
dlt = D.pop('a')
dlt
> 1

D
> {'b': 2, 'c': 3}
```

### 5.6. Changing dictionary representation



#### Sorting Keys

Through list «sort» method.

```powershell
>>> D = {'name': 'Bob', 'age': 45}
>>> keys = list(D.keys())
>>> keys.sort()
>>> for key in keys:
...    print(key, '=>', D[key])
...
age => 45
name => Bob
```

Through «sorted» method

```powershell
>>> sorted(D)
['age', 'name']
>>> for key in sorted(D):
...    print(key, '=>', D[key])
...
age => 45
name => Bob
```

```python
sorted_dict = dict(sorted(unsorted_dict.items()))
```

ADD ONE DICTIONARY TO ANOTHER

**Self assignment**

#### Type-specific methods

## 6. File

### 6.1. Create, open for writing and write

#### 6.1.1. Create

Creating means opening for writing, if file doesn't exist, it'll be created.

**Attention!** If file exist it will erace everything.

If file opened for reading you can't write.

##### 6.1.1.1. How to create file from scratch

```python
F = open('path', 'w')
type(F)
> _io.TextIOWrapper
```

It's better to use raw string for path in Windows OS:

```python
F = open(r'C:\folder\file', 'w')
```

##### 6.3.1. Write a string into file (erase everything)

```python
F = open('/Users/master/Desktop/file.txt', 'w')
F.write('5555')
F.close()
```

##### 6.1.1.1. How to write into file from scratch

```python
F = open('/Users/master/Desktop/file.txt', 'w')
F.write('1111\n')
F.write('2222')
F.close()

with open('/Users/master/Desktop/file.txt', 'r') as fl:
    print(fl.readlines())
  
> ['1111\n', '2222']
```

##### 6.1.1.1. How to write into the end of the file?

```python
F = open('/Users/master/Desktop/file.txt', 'a')
F.write('3333\n')
F.close()

with open('/Users/master/Desktop/file.txt', 'r') as fl:
	for line in fl: print(line)

> 1111
2222
3333
```

##### How to write several lines into a file?

```python
F = open('/Users/master/Desktop/file.txt', 'a')
F.writelines(['\n4444\n', '5555'])
F.close()

with open('/Users/master/Desktop/file.txt', 'r') as fl:
	for line in fl: print(line)
    
> 1111
2222
3333
4444
5555
```

#### Write as a bytestring

End of line translation and unicode encodings are turned off

```python
F = open('/Users/master/Desktop/file.txt', 'wb')
```



#### Open with encoding

```python
F = open('/Users/master/Desktop/file.txt', 'w', encoding = 'utf8')
```



### Open for reading and read file

##### 6.1.1.2. How to open for read existing file?

If file opened for reading you can't write.

```python
F = open('path/file', 'r')

# In the same folder

F = open('file', 'r')
```

Short form:

```python
F = open('file')
```

##### 6.1.1.3. What if file doesn't exist?

```python
F = open('not_existing_file', 'r')
> FileNotFoundError: [Errno 2] No such file or directory: 'not_existing_path'
```

### 6.2. Read content

#### 6.2.1. Read

##### 6.2.1.1. How to read entire file?

```python
F = open('/Users/master/Desktop/file.txt')
S = F.read()
S
> '1111\n2222\n3333\n4444'
```

##### 6.2.1.2. How to read all lines in one go but separately (as list of lines)?

```python
F = open('/Users/master/Desktop/file.txt')
aList = F.readlines()
aList
> ['1111\n', '2222\n', '3333\n', '4444']
```

#### 6.2.2. Read characters or line

##### 6.2.1.2. How to read up to specific character offset in the file?

```python
F = open('/Users/master/Desktop/file.txt')
String_1 = F.read(5)
String_1
> '1111\n'

String_2 = F.read(5)
String_2
> '2222\n'
```

##### 6.2.1.3. How to read single line?

```python
F = open('/Users/master/Desktop/file.txt')
LineAsString_1 = F.readline()
LineAsString_1
> '1111\n'

Line_2 = F.readline()
Line_2
> '2222\n'
```

##### How to change position (offset of reading) in the file

```python
F = open('/Users/master/Desktop/file.txt', 'r')
print(F.readlines())
> ['1111\n', '2222\n', '3333\n', '4444\n', '5555']

F.seek(0)
print(F.read(5))
> 1111

F.seek(10)
print(F.read(5))
> 3333
```

##### How to get know if file is finished?

Read line method will return an empty string:

```python
F = open('/Users/master/Desktop/file.txt', 'w')
F.write('111\n')
F.write('222\n')
F.close()

F = open('/Users/master/Desktop/file.txt', 'r')
F.readline()
> '111'
F.readline()
> '222'
F.readline()
> ''
F.readline()
> ''
```

Next method

```python
F = open('/Users/master/Desktop/file.txt', 'r')
F.__next__()
> '1111\n'

next(F)
> '2222\n'

next(F)
> StopIteration: 
```

Read all lines in file and clearify them from new line symbols:

```python
F = open('/Users/master/Desktop/file.txt', 'r')
lines = [line.rstrip() for line in F]
lines
> ['1111', '2222', '3333']
```

Unpack file:

```python
F = open('/Users/master/Desktop/file.txt', 'r')
print(*F)
>
1111
 2222
 3333
```



### 6.1.2. Close

```python
F = open('path', 'w')
F.close()
```

Autoclose in **with / as** statement:

```python
with open('path', 'w') as F:
  pass
```

### 6.1.3. Flush

Forces buffered data to disk

```python
FW = open('path', 'w')
FW.write('123')
FW.flush
FR = open('path', 'r')
print(FR.read())
> 123

FR.close()
FW.close()
```

### Pickle

### JSON

### CSV

### Binary

### File context manager

## 7. Other Types

### 7.1. None

```python
# None

z = None
print(z)
print(type(z))
print(bool(z))
# print(int(z)) # doesn't work
# print(float(z)) # doesn't work
print(str(z))
```



