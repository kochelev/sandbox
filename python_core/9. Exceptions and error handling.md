# Exceptions and error handling

There are several syntax patterns for exceptions:

- **try / except** — catch and recover from exceptions raised by Python or by written code.

- **try / finally** — perform cleanup actions, whether exceptions occur or not.

- **raise** — triggers an exception manually.

- **assert** — conditionally triggers an exception.

- **with / as** — implement context managers.

Usage:

- Helps to prevent crash application when interpreter faced with some errors (error handling).
- Helps to signal valid conditions without you having to pass result flags around the program or test them explicitly.
- To catch errors in convoluted code.
- With try / finally  and with / as one can terminate actions.
- Implement backtracking, but with saving old state of code.

## 1. Catching Exceptions

### 1.1. «try» statement

#### 1.1.1. Give a common TRY syntax example with all statements

Common Syntax:

```python
try:
    raise IndexError
except IndexError:
    print('Got an IndexError')
except:
    print('Got othe error')
else:
  print('No Errors')
  
print('Continuing...')
```

#### 1.1.2. What will happen if current TRY statement didn't catch an error

If exception is not caught, it is propagated up to the top-level default exception handler and terminate the program with a standart error message.

```python
try:
    raise ZeroDivisionError
except IndexError:
    print('Got an IndexError')

> ZeroDivisionError: division by zero
```

#### 1.1.3. Give a full example of try expression

```python
try:
    pass
except IndexError:
    pass
except (KeyError, TypeError):
    pass
except SyntaxError as var:
    pass
else:
    pass
finally:
    pass
```

#### 1.1.4. How it's better to catch undefined errors

```python
try:
    raise KeyboardInterrupt
except Exception as var:
    print('Was caught:', var.__class__)

> KeyboardInterrupt:

try:
    raise IndexError
except Exception as var:
    print('Was caught:', var.__class__)

> Was caught: <class 'IndexError'>
```

#### 1.1.5. Why it is better to use else statement? Give examples

This can handle errors in the code "if OK":

```python
try:
    l = [0, 1, 2]
    l[1]
    # l[4]
except Exception:
    print('error')
else:
    print('if OK', 3/0)

> ZeroDivisionError
```

#### 1.1.6. How try|except|as expression influences the Scope?

Except|as statement kills any variable with the same name.

```python
X = 5

try:
    raise IndexError
except Exception as X:
    pass

print(X)

> NameError: name 'X' is not defined
```

#### 1.1.7. Save exception example

```python
try:
    raise IndexError
except Exception as X:
    Saved = X

print(Saved.__class__)

> <class 'IndexError'>
```

## 2. Raising Exceptions

### 2.1. Raise statement

#### 2.1.1. Give example of raising index error

```python
raise IndexError

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError
```

#### 2.1.1.a. Give example of raising index error with custom text

```python
I = IndexError('spam')
print(I.args)

> ('spam',)

print(I)

> spam

raise I

> IndexError: spam
```

#### 2.1.2. What will be raised via raising build in exceptions?

Always an instance:

```python
raise IndexError

> IndexError:

raise IndexError()

> IndexError:
```

#### 2.1.3. Show what can be raised by raise statement

A class:

```python
class MyException(Exception):
    pass

raise MyException

> MyException:
```

An Instance of class:

```python
class MyException(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg

I1 = MyException('text 1')
I2 = MyException('text 2')

raise I1

> MyException: text 1

raise I2

> MyException: text 2
```

#### 2.1.4. Show raising instance with try/except/as expression

```python
class MyException(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg

try:
    raise MyException('text')
except MyException as X:
    print(X.args)

> ('text',)
```

#### 2.1.5. Give example of propagating exceptions to the top-level handler

```python
try:
    raise IndexError('Hello')
except Exception:
    print('Exception was caught')
    raise

> Exception was caught
> IndexError: Hello
```

#### 2.1.5. What error message is consist of?

User-triggered exceptions are the same as system triggered.

Error messages include the exception that was raised, along with a **stack trace** — a list of all the lines and functions that were active when the exception occured.

The IDLE's interactive shell error messages can differ from python shell messages.

**\<stdin>** is a standard input stream.

### 2.2.a. Exception chains with RAISE ... FROM

```python
try:
    1 / 0
except Exception as X:
    Y = TypeError('Bad')
    raise Y from X
finally:
    print(Y.__cause__)

>
division by zero

ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

TypeError: Bad
```

```python
try:
    try:
        raise IndexError()
    except Exception as E:
        raise TypeError from E
except Exception as E:
    raise SyntaxError from E
```

### 2.2. Assert statement

#### 2.2.1. Give an example of assert exception

**assert** is a conditional **raise**. It is used mostly for debugging purpuses.

```python
assert False, 'Assert Exception'

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: Assert Exception
```

#### 2.2.2. Give an alternative way of assert expression

```python

if __debug__:
    if not False:
        raise AssertionError('Assert Exception')

> AssertionError: Assert Exception
```








**finally** — specifies termination actions that always execute «on the way out», regardless of whether an exception occurs in the **try** block or not.

It doesn't make sence with **except** statement.

**try / except** combinations are useful for catching and recovering from exceptions.

**try / finally** combinations come in handy to guarantee that termination actions will fire regardless of any exceptions that may occure in the **try** block's code, to close files or terminate server connections.

with / as statement runs an object's context management logic to guarantee that termination actions occure, irrespective of any exceptions in its nested block.

It's applicable only when processing certain object types that support it.

```python
with open('test.txt', 'w') as file:
  file.write('Line 1\n')
```

## 3. User-Defined Exceptions

#### 3.1. Create a custom exception without any message

User-defined exceptions are coded with classes, which inherit from a built-in exception class **Exception**.

```python
class MyException(Exception): pass

raise MyException()

> MyException:
```

#### 3.2. Create a custom exception with error message

Change the error message.

```python
class MyException(Exception):
    def __str__(self): return "My error message!"

raise MyException()

> MyException: My error message!
```

```python
class MyException(Exception):
    def __str__(self): return "My error message!"

try:
    raise MyException()
except MyException as X:
    print(X)

> My error message!
```

#### 3.2.a. What will be show when __repr__ (__str__) were set in the class, and constructor gives text

```python
class E(Exception):
    def __repr__(self):
        return 'Repr'
    
raise E('Constructor')

> E: Constructor
```

But:

```python
class MyException(Exception):
    def __str__(self):
        return 'Str'
    
raise MyException('Constructor')

> MyException: Str
```

#### 3.3. Create an exception and pass params

```python
class MyException(Exception):
    def __init__(sefl, x):
        self.x = x
    def __str__(self):
        return 'error with param %i' % self.x

raise MyException(3)

> MyException: error with param 3
```

With **try** statement:

```python
try:
    raise MyException(3)
except MyException as X:
    print('Error: ', X.x)

> Error: 3
```

#### 3.4. Create a simple exception with logging

```python
import datetime

class MyException(Exception):
    logfile = '/Users/master/Desktop/log.txt'
    def __init__(self, point, text):
        self.point = point
        self.text = text
    def log(self):
        f = open(self.logfile, 'a')
        f.write(
            datetime.datetime.now().isoformat() +
            '| Error at: %d, data: %s' %
            (self.point, self.text) + '\n')

if __name__ == '__main__':
    try:
        raise MyException(40, 'text')
    except MyException as exc:
        exc.log()
```

## 4. Terminating actions

### 4.1. try...finally statement

#### 4.1.1. Give a simple example of try|finally expression

```python
try:
    raise IndexError
finally:
    print("finally")
```

```python
try:
    f = open('/Users/master/Desktop/new.txt', 'wb')
    raise IndexError
finally:
    f.close()

> IndexError:
```

#### 4.1.2. Give an example of usage terminating in a function

With exception:

```python
def func():
    try:
        raise IndexError
    finally:
        print('Finally')
    print('After try')

func()

> Finally
> IndexError:
```

Without excepton:

```python
def func():
    try:
        pass
    finally:
        print('Finally')
    print('After try')

func()

> Finally
> After try
```

### 4.2. with|as context manager

#### 4.2.1. Create a file opening with as construction

```python
with open('/Users/master/Desktop/file.txt', 'rb') as myfile:
    for line in myfile:
        print(line)
    
> line 1
> line 2
...
```

#### 4.2.2. Create a decimal context construction

```python
import decimal

with decimal.localcontext() as ctx:
    ctx.prec = 2
    x = decimal.Decimal('1.00') / decimal.Decimal('3.00')
    print(x)

> 0.33
```

#### 4.2.3. Create a class which supports context protocol

```python
class One:
    def func(self, arg):
        print(arg)
    def __enter__(self):
        print('Start with block')
        return self
    def __exit__(self, ex_type, ex_value, ex_traceback):
        if ex_type is None:
            print(ex_type, ex_value, ex_traceback)
            print('Finished without error')
        else:
            print(ex_type, ex_value, ex_traceback)
            print('Finished with ERROR', str(ex_type))
            return False

if __name__ == "__main__":
    with One() as X:
        X.func('text')
        print('Done')

    with One() as X:
        raise IndexError('Error Text')
        print('Not reached text')

>
Start with block
text
Done
None None None
Finished without error
Start with block
<class 'IndexError'>  <traceback object at 0x113f555a0>
Finished with ERROR <class 'IndexError'>
IndexError: Error Text
```

#### 4.2.4. Give an example of multiple context managers

```python
with One() as X, open('.../file.txt', 'rb') as myfile:
    pass
```

```python
with open('script1.py') as f1, open('script2.py') as f2:
    for pair in zip(f1, f2):
        print(pair)
```

## 5. Exception Objects

#### 5.1. List Python exception hierarchy

1. BaseException (is not supported to be directly inherited)
    1.1. System exit event classes: SystemExit, KeyboardInterrupt, GeneratorExit).
    1.2. Exception (superclass for all system exceptions and root for user defined exceptions)
        1.2.1. ArithmeticError (root of numeric errors)
            - OverflowError
            - ZeroDivisionError
            - Floating PointError
        1.2.2. LookupError (root of indexing errors)
        1.2.3. OSError

#### 5.2. Give an example of catching No Such File error (3 ways)

With **errno**:

```python
try:
    f = open('nonesuch.txt')
except IOError as V:
    if V.errno == 2:
        print('No such file')
    else:
        print('Not 2')
else:
    raise

> No such file
```

With **args**:

```python
try:
    f = open('nonesuch.txt')
except IOError as V:
    if V.V.args[0] == 2:
        print('No such file')
    else:
        print('Not 2')
else:
    raise

> No such file
```

With **FileNotFoundError**:

```python
try:
    f = open('nonesuch.txt')
except FileNotFoundError:
    print('No such file')

> No such file
```

## 6. Designing with Exceptions

#### 6.1. How to break out of Multiple Nested Loops

```python
class Exitloop(Exception):
    pass

try:
    while True:
        while True:
            for i in range(10):
                if i > 3: raise Exitloop
                print('loop3: ', i)
            print('loop2: ', i)
        print('loop1: ', i)
except Exitloop:
    print('continuing')

loop3:  0
loop3:  1
loop3:  2
loop3:  3
continuing
```

#### 6.2. Use exception to catch end of file

NOT FINISHED

```python
try:
    f = open('/Users/master/Desktop/file.txt', 'wb')
    for line in f:
        print(line)
except EOFerror:
    print('THE END')

while True:
    try:
        line = input()
    except EOFError:
        print('YOUR DATA WAS CATCHED')
        break
    else:
        print('ho ')
print(line)

```
            
#### 6.3. Create a searcher of a single entry with exception

```python
class Found(Exception):
    def __init__(self, data):
        self.data = data
    
L = [0, 3, 5, 2, 5]

def find(x):
    for index, i in enumerate(L):
        if i == x:
            raise Found(index)

try:
    find(3)
except Found as F:
    print(F.data)
else:
    print('Din\'t find')

> 1
```

Opposite:

```python
class NotFound(Exception): pass
    
L = [0, 3, 5, 2, 5]

def find(x):
    if x in L:
        return('Success')
    else:
        raise NotFound()

try:
    res = find(3)
except NotFound as F:
    print('Din\'t find')
else:
    print(res)

> Success
```

#### 6.3. How to debug with outer TRY statement?

```python
try:
    raise IndexError
except:
    import sys
    print('Uncaught!', sys.exc_info()[0], sys.exc_info()[1])

> Uncaught! <class 'IndexError'> 
```