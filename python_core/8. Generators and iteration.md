# Generators

Generators can be implemented as functions or comprehension expressions.

Generators produce results on demand.

## 1. Iterators and iterables

### What is iteration?

#### How can you call next element (2 ways)?

```python
gen = (x for x in range(1, 10))
print(next(gen))
> 1

print(gen.__next__())
> 2
```

### Iterable objects

#### How to create iterator from iterable objects (list all)?

```python
L = [1, 2, 3, 4]
T = ('a', 'b', 'c', 'd')
D = {x: y for (x, y) in zip(L, T)}
S = 'abcd'
R = range(1, 10)

iter(L) is L
iter(T) is T
iter(D) is D
iter(S) is S
iter(R) is R

> False
> False
> False
> False
> False

I1 = iter(L)
I2 = iter(T)
I3 = iter(D)
I4 = iter(S)
I5 = iter(R)
next(I1)
next(I2)
next(I3)
next(I4)
next(I5)

> 1
> a
> 1
> a
> 1
```

#### Dictionary iterable methods

#### Show how keys() works

```python
D = {x: y for x, y in zip(range(1, 4), 'abc')} # {1: 'a', 2: 'b', 3: 'c'}
D.keys()
> dict_keys([1, 2, 3])

K = iter(D.keys())
next(K)
> 1

V = iter(D.values())
next(V)
> 'a'

I = iter(D.items())
next(I)
> (1, 'a')
```



#### Range as list properties

```python
R = range(10)
print(R)
> range(0, 10)

print(len(R))
> 10

print(R[4])
> 4
```

But iterator doesn't have such properties:

```python
R = range(10)
I = iter(R)
print(len(I))
> TypeError: object of type 'range_iterator' has no len()
```

### Iterators

#### Enumerate iterator, give example

```python
E = enumerate('abcd')
iter(E) is E

> True

next(E)

> (0, 'a')

list(E)

> [(1, 'b'), (2, 'c'), (3, 'd')]
```

#### ZIP iterator

```python
Z = zip([1, 2, 3], ['a', 'b', 'c'])
Z
> <zip object at 0x10adbff50>

next(Z)
> (1, 'a')
```

#### MAP iterator

```python
M = map(abs, (-5, 2, -3, 4, 5, -2))
next(M)
> 5
```

#### FILTER iterator

```python
F = filter(bool, (-5, '', 'abc', 2, 'True'))
next(F)
> -5

next(F)
> 'abc'
```



## Generator Functions

#### Create a simple generator with function

```python
def gen(max):
    for i in range(1, max + 1):
        yield i
    return 'Message for StopIteration Exception'

I = gen(3)

next(I)

> 1

...

next(I)

> StopIteration: Message for StopIteration Exception
```

#### Show that generator based on function statement can be assigned multiple times

```python
def squares(x):
    for i in range(x):
        yield i ** 2

first = squares(4)
second = squares(5)

print(next(first))

> 0

print(next(first))

> 1

print(next(second))

> 0
```

#### Create a generator as a function which counts from 1 to 3 and back

```python
def gen(max):
    for i in range(1, max + 1):
        yield i
    for k in range(max, 0, -1):
        yield k
    return 'Message for StopIteration Exception'

I = gen(3)

next(I)

> 1
```

#### Create an infinite generator counting from 1 to 3 and back and again

```python
def gen(max):
    while True:
        for i in range(1, max + 1):
            yield i
        for k in range(max, 0, -1):
            yield k
    
I = gen(3)

next(I)
```

#### Create a generator without for statement

```python
def gen():
    yield 1
    yield 2
    yield 3
    return 'Finished'

I = gen()

next(I)
```

#### Show that generator is its own iterator

```python
iter(I) is I

> True
```

#### Assigning yield

```python
def gen(x):
    for i in range(x):
        A = yield i
        print(A)

I = gen(3)

next(I)
```

#### Create a generator which can change step

```python
def gen(x):
    step = 1
    i = 1
    while True:
        catch = yield i
        if catch is not None:
            step = catch
        i += step

I = gen(10)

next(I)

I.send(3)
```

#### throw(type)
#### close

### Yield from extension

#### Create a simple generator with «yield from» statement

```python
def both(N):
    yield from range(N)
    yield from (x ** 2 for x in range(N))

list(both(5))

> [0, 1, 2, 3, 4, 0, 1, 4, 9, 16]
```

## Expressions

#### Write simple generator with expression

```python
G = (x for x in range(1, 11))

print(G)

> <generator object <genexpr> at 0x106605e50>

next(G)

> 1
```

#### Do we have to use iter

```python
iter(G) is G

> True
```

#### Do we need to use extra parenthesis

In this case we don't need:

```python
S = sum(x ** 2 for x in range(1,5))

print(S)

K = sorted(x ** 2 for x in range(1,5))

print(K)
```

In this — we need:

```python
K = sorted((x ** 2 for x in range(1,5)), reversed = True)

print(K)
```

#### Create a nested generator

```python
L = list(x * 2 for x in (abs(x) for x in (-1, -2, 3, 4)))

print(L)

> [2, 4, 6, 8]
```

#### Create a generator with if statement (give only odd numbers)

```python
G = (x for x in range(1, 11) if x % 2 != 0)

next(G)

> 1
```

#### Illustrate that generator is one shot iterator

```python
G = (x for x in range(1, 11))
A = iter(G)
B = iter(G)

next(G)

> 1

next(A)

> 2

next(B)

> 3
```



# 6. Generators

```python
>>> squares = (x ** 2 for x in [1,2,3,4,5])
>>> next(squares)
1
>>> next(squares)
4
...
>>> next(squares)
StopIteration
```

### 3. Generator Function

Arguments with default values should be placed in the end of the arguments list.

5.2.4. Arguments collectors

```python
def func(x, *other):
  print(x)
  print(*other)
  print(other)
  print(type(other))
  
func(1, 2, 3, 4)

> 1
  2 3 4
	(2, 3, 4)
  <class 'tuple'>
```

## 5.3. Yield

```python
def squares(x):
    for i in range(x):
        yield i ** 2

first = squares(4)
second = squares(5)

print(next(first))

> 0

print(next(first))

> 1

print(next(second))

> 0
```

More on generators look at Lutz's Learning Python page 606.